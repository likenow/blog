## OpenGL

[toc]



> Thanks https://youtube.com/playlist?list=PLlrATfBNZ98foTJPJ_Ev03o2oq3-GGOS2 Cherno

### welcome

OpenGL is just a spec(specification), cross-platform

AMD Intel ... So everyone's implementation of OpenGL is gonna be slightly different

Legacy opengl

Modern Opengl

### Setting up OpenGL and Creating a Window in C++

GLFW

What you compile your application with, so we'll just be using a 32-bit application because we don't need a 64-bit one

æ·»åŠ ä¾èµ–åº“



```c++
âŒ
LNK2019
unresolved external symbol __imp_glClear referenced in function main

What link is trying to do now is find a definition for 
that glClear Function That is inside an opengl library file
so we actuall have to link against that.

Project --> Properties --> Linker --> input --> additional dependencies
opengl32.lib;
```



ä»£ç ï¼š

```c++

#include <iostream>
#include "GLFW/glfw3.h"

int main()
{
    GLFWwindow* window;

    /* Initialize the library */
    if (!glfwInit())
        return -1;

    /* Create a windowed mode window and its OpenGL context */
    window = glfwCreateWindow(640, 480, "Hello World", NULL, NULL);
    if (!window)
    {
        glfwTerminate();
        return -1;
    }

    /* Make the window's context current */
    glfwMakeContextCurrent(window);

    /* Loop until the user closes the window */
    while (!glfwWindowShouldClose(window))
    {
        /* Render here */
        glClear(GL_COLOR_BUFFER_BIT);

        glBegin(GL_TRIANGLES);
        
        // draw a triangle
        glVertex2f(-0.5f, -0.5f);
        glVertex2f(0.0f, 0.5f);
        glVertex2f(0.5f, -0.5f);

        glEnd();

        /* Swap front and back buffers */
        glfwSwapBuffers(window);

        /* Poll for and process events */
        glfwPollEvents();
    }

    glfwTerminate();
    return 0;
}
```



### Using Modern OpenGL in C++

Pull out the functions and call them

Get  the function Declarations and then link against the functions as well

So we need to access the driver's DLL files and just retrieve the function pointers

to the functions inside those libraries . That's what we need to do.

#### [glew](https://glew.sourceforge.net/)

æ”¾åˆ° `\Dependencies\GLEW` ç›®å½•ä¸‹

æ·»åŠ æ–°çš„é™æ€åº“ä¾èµ–

```c++
/*
Configuration    Platform
 C/  C++   --> General --> Additional include Directories ï¼ˆ$(SolutionDir)Dependencies\GLEW\includeï¼‰
 C/  C++   --> linker --> general --> Additional library directoriesï¼ˆ$(SolutionDir)Dependencies\GLEW\lib\Release\x64ï¼‰
  (è¿™é‡ŒåŒ…å«ä¾èµ–åº“æ–‡ä»¶çš„æ ¹ç›®å½•)  
 C/  C++   --> linker --> input --> Additional Dependencies ("glew32s.lib" for 32-bit builds, "glew32s.lib" for 64-bit builds)
  
  */

/*
âŒ
Build started...
1>------ Build started: Project: DemoLibrary, Configuration: Debug x64 ------
1>LINK : warning LNK4098: defaultlib 'MSVCRT' conflicts with use of other libs; use /NODEFAULTLIB:library
1>Main.obj : error LNK2019: unresolved external symbol __imp_glewInit referenced in function main
1>Main.obj : error LNK2019: unresolved external symbol __imp_glewGetErrorString referenced in function main
1>C:\Users\fmsli\dev\DemoLibrary\bin\x64\Debug\DemoLibrary.exe : fatal error LNK1120: 2 unresolved externals
1>Done building project "DemoLibrary.vcxproj" -- FAILED.
========== Build: 0 succeeded, 1 failed, 0 up-to-date, 0 skipped ==========
========== Build started at 6:52 PM and took 00.429 seconds ==========
#include <GL/glew.h> // åœ¨ #include "GLFW/glfw3.h" ä¹‹å‰
  
  */

/*
 * GLEW_STATIC is defined for static library.
 * GLEW_BUILD  is defined for building the DLL library.
 
 C/  C++   --> Preprocessor --> Preprocessor Definitions --> GLEW_STATIC
 */
 
 
```



### Vertex Buffers and Drawing a Triangle in OpenGL

- Create a vertex **buffer** åˆ›å»ºä¸€ä¸ªé¡¶ç‚¹ç¼“å†²åŒº
- Create a shader åˆ›å»ºä¸€ä¸ªç€è‰²å™¨

State machine

Contextual ä¸Šä¸‹æ–‡ç›¸å…³çš„

Vertex attribute stuff

Shader

Index buffer

### Vertex Attritures and Layouts in OpenGL

é¡¶ç‚¹å±æ€§å’Œå¸ƒå±€

é¡¶ç‚¹ä¸ä»…ä»…æ˜¯ä½ç½®ï¼ï¼ï¼A vertex can contain way more than just a position!

å±æ€§ï¼š

- Position ä½ç½®
- Texture coordinate çº¹ç†åæ ‡
- Normal æ³•çº¿

Index ç´¢å¼•

```C++
    // enable
    glEnableVertexAttribArray(0);
    /*
    stride æ˜¯æ¯ä¸ªé¡¶ç‚¹ä¹‹é—´çš„å­—èŠ‚æ•°
    the stride is the amount of bytes that we have between each vertex

    pointer æ˜¯æ¯ä¸ªå±æ€§ä¹‹é—´çš„å­—èŠ‚æ•°
    */
    glVertexAttribPointer(0, 2, GL_FLOAT, GL_FALSE, sizeof(float) * 2, (const void*)0);
    
```

å¹³å°æä¾›é»˜è®¤ç€è‰²å™¨ï¼Œä¸å»ºè®®è¿™æ ·ä½¿ç”¨ã€‚

### How Shaders Work in OpenGL

**pipeline**

- Vertex shaders 
  - é¡¶ç‚¹ç€è‰²å™¨ -- æŒ‡å®šäº†ä½ç½®/ è½¬æ¢ï¼ˆit specifies the way you want to on the positions to beï¼‰
- Fragmentï¼ˆpixelï¼‰ shaders 
  - ç‰‡æ®µç€è‰²å™¨ rasterized å…‰æ …åŒ–ï¼ˆå¯¹ä¸‰è§’å½¢ä¸­éœ€è¦å¡«å……çš„æ¯ä¸ªåƒç´ è°ƒç”¨ä¸€æ¬¡ï¼‰å†³å®šåƒç´ åº”è¯¥æ˜¯ä»€ä¹ˆé¢œè‰²
- ... è¿˜æœ‰å¾ˆå¤šç€è‰²å™¨

### Writing a Shader in OpenGL

æˆ‘ä¼šåœ¨ç¼–è¯‘æœŸé—´æŠŠå®ƒï¼ˆæ–‡æœ¬ï¼‰æ‰“åŒ…è¿›æœ€ç»ˆç¨‹åºæ–‡ä»¶

```C++
static unsigned int CompileShader(unsigned int type, const std::string& source)
{
    unsigned int id = glCreateShader(type);
    const char* src = source.c_str();
    glShaderSource(id, 1, &src, nullptr);
    glCompileShader(id);

    // TODO: Error handling
    int result;
    glGetShaderiv(id, GL_COMPILE_STATUS, &result);
    if (result == GL_FALSE)
    {
        int length;
        glGetShaderiv(id, GL_INFO_LOG_LENGTH, &length);
        char* message = (char*)alloca(length * sizeof(char));
        glGetShaderInfoLog(id, length, &length, message);
        std::cout << "Failed  to Compile " <<
            (type == GL_VERTEX_SHADER ? "vertex" : "fragment") << "shader ! " << message << std::endl;
        glDeleteShader(id);
        return 0;
    }

    return id;
}

static int CreateShader(const std::string& vertexShader, const std::string& fragmentShader)
{
    unsigned int program = glCreateProgram();
    unsigned int vs = CompileShader(GL_VERTEX_SHADER, vertexShader);
    unsigned int fs = CompileShader(GL_FRAGMENT_SHADER, fragmentShader);

    // attach
    glAttachShader(program, vs);
    glAttachShader(program, fs);
    // link
    glLinkProgram(program);
    // valid
    glValidateProgram(program);

    glDeleteShader(vs);
    glDeleteShader(fs);
    // glDetach  -- pro operation

    return program;
}

void f2()
{
    // positions
    float positions[6] = {
        -0.5f, -0.5f,
         0.0f,  0.5f,
         0.5f, -0.5f
    };
    // this is the id of the generated buffer object
    unsigned int buffer;
    glGenBuffers(1, &buffer);
    // bindding buffer memory <--> buffer object
    glBindBuffer(GL_ARRAY_BUFFER, buffer);
    // specify the data
    glBufferData(GL_ARRAY_BUFFER, 6 * sizeof(float), positions, GL_STATIC_DRAW);

    // enable
    glEnableVertexAttribArray(0);
    // attribute
    glVertexAttribPointer(0, 2, GL_FLOAT, GL_FALSE, sizeof(float) * 2, (const void*)0);

    // bindding buffer memory <--> buffer object
    glBindBuffer(GL_ARRAY_BUFFER, 0);

    // shader
    std::string vertexShader = 
        "#version 330 core\n"
        "\n"
        "layout(location = 0) in vec4 position;"
        "\n"
        "void main()\n"
        "{\n"
        "   gl_Position = position;\n"
        "}\n";

    std::string fragmentShader =
        "#version 330 core\n"
        "\n"
        "layout(location = 0) out vec4 color;"
        "\n"
        "void main()\n"
        "{\n"
        "   color = vec4(1.0, 0.0, 0.0, 1.0);\n"
        "}\n";

    unsigned int shader = CreateShader(vertexShader, fragmentShader);
    glUseProgram(shader);
}
```

### How I Deal with Shaders in OpenGL

å°†ä¸¤ä¸ªç€è‰²å™¨æºç æ–‡ä»¶åˆå¹¶åˆ°ä¸€ä¸ªæ–‡ä»¶ä¸­ã€‚ä»æ–‡ä»¶è¯»å– shader

> Direct X is a Better API ğŸ¶

Relative Path

```undefined
projects -> configuration  -> properties  -> debugging  -> working directory -> $(ProjectDir)
```

### Index Buffers in OpenGL

ç´¢å¼•ç¼“å†²åŒº

å®Œå…¨å”¯ä¸€çš„é¡¶ç‚¹

Same memory multiple times

é‡å¤å†—ä½™å†…å­˜

å¿…é¡»æ˜¯æ— ç¬¦å·å†…å®¹

```C++
#include <fstream>
#include <string>
#include <sstream>

struct ShaderProgramSource
{
    std::string VertexSource;
    std::string FragmentSource;
};

static ShaderProgramSource ParseShader(const std::string& filePath)
{
    std::ifstream infile(filePath);
    if (!infile)
    {
        std::cout << "Error opening file \n";
    }

    enum class ShaderType
    {
        NONE = -1, VERTEX = 0, FRAGMENT = 1
    };
    
    std::string line;
    // for vertex shader and fragment shader
    std::stringstream ss[2];
    ShaderType type = ShaderType::NONE;

    while (std::getline(infile, line)) {
        if (line.find("#shader") != std::string::npos)
        {
            if (line.find("vertex") != std::string::npos)
            {
                type = ShaderType::VERTEX;
            }
            else if (line.find("fragment") != std::string::npos)
            {
                type = ShaderType::FRAGMENT;
            }
        }
        else
        {
            ss[(int)type] << line << '\n';
        }
        
    }
    infile.close();

    return {ss[0].str(), ss[1].str()};
}

static unsigned int CompileShader(unsigned int type, const std::string& source)
{
    unsigned int id = glCreateShader(type);
    const char* src = source.c_str();
    glShaderSource(id, 1, &src, nullptr);
    glCompileShader(id);

    // TODO: Error handling
    int result;
    glGetShaderiv(id, GL_COMPILE_STATUS, &result);
    if (result == GL_FALSE)
    {
        int length;
        glGetShaderiv(id, GL_INFO_LOG_LENGTH, &length);
        char* message = (char*)alloca(length * sizeof(char));
        glGetShaderInfoLog(id, length, &length, message);
        std::cout << "Failed  to Compile " <<
            (type == GL_VERTEX_SHADER ? "vertex" : "fragment") << "shader ! " << message << std::endl;
        glDeleteShader(id);
        return 0;
    }

    return id;
}

static int CreateShader(const std::string& vertexShader, const std::string& fragmentShader)
{
    unsigned int program = glCreateProgram();
    unsigned int vs = CompileShader(GL_VERTEX_SHADER, vertexShader);
    unsigned int fs = CompileShader(GL_FRAGMENT_SHADER, fragmentShader);

    // attach
    glAttachShader(program, vs);
    glAttachShader(program, fs);
    // link
    glLinkProgram(program);
    // valid
    glValidateProgram(program);

    glDeleteShader(vs);
    glDeleteShader(fs);

    return program;
}

unsigned int f2()
{
    // positions
    /*
    float positions[6] = {
        -0.5f, -0.5f,
         0.0f,  0.5f,
         0.5f, -0.5f
    };
    */
    /*
    // repeat and waste
    float positions[12] = {
        -0.5f, -0.5f,
         0.5f, -0.5f,
         0.5f,  0.5f,
         0.5f,  0.5f,
        -0.5f,  0.5f,
        -0.5f, -0.5f
    };
    */
    // use index buffer
    float positions[12] = {
        -0.5f, -0.5f,
         0.5f, -0.5f,
         0.5f,  0.5f,
        -0.5f,  0.5f
    };

    unsigned int indices[] = {
        0, 1, 2,
        2, 3, 0
    };

    // this is the id of the generated buffer object
    unsigned int buffer;
    glGenBuffers(1, &buffer);
    // bindding buffer memory <--> buffer object
    glBindBuffer(GL_ARRAY_BUFFER, buffer);
    // specify the data
    glBufferData(GL_ARRAY_BUFFER, 6 * 2 * sizeof(float), positions, GL_STATIC_DRAW);

    // enable
    glEnableVertexAttribArray(0);
    // attribute
    glVertexAttribPointer(0, 2, GL_FLOAT, GL_FALSE, sizeof(float) * 2, (const void*)0);

    unsigned int ibo;
    glGenBuffers(1, &ibo);
    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, ibo);
    glBufferData(GL_ELEMENT_ARRAY_BUFFER, 6 * sizeof(unsigned int), indices, GL_STATIC_DRAW);

    // relative path, which always from th working directory
    ShaderProgramSource source = ParseShader("res/shaders/Basic.shader");
    std::cout << "VertexSource" << std::endl;
    std::cout << source.VertexSource << std::endl;
    std::cout << "FragmentSource" << std::endl;
    std::cout << source.FragmentSource << std::endl;
    unsigned int shader = CreateShader(source.VertexSource, source.FragmentSource);
    glUseProgram(shader);
    return shader;
}

void f2_1()
{
    // 6 is in the index buffer
    // any index buffer has to be made up of unsigned int !!!
    glDrawElements(GL_TRIANGLES, 6, GL_UNSIGNED_INT, nullptr);
}
int main()
{
    GLFWwindow* window;

    /* Initialize the library */
    if (!glfwInit())
        return -1;

    /* Create a windowed mode window and its OpenGL context */
    window = glfwCreateWindow(640, 480, "Hello World", NULL, NULL);
    if (!window)
    {
        glfwTerminate();
        return -1;
    }

    /* Make the window's context current */
    glfwMakeContextCurrent(window);

    GLenum err = glewInit();
    if (GLEW_OK != err)
    {
        /* Problem: glewInit failed, something is seriously wrong. */
        fprintf(stderr, "Error: %s\n", glewGetErrorString(err));

    }

    // f1();

    unsigned int shader = f2();



    /* Loop until the user closes the window */
    while (!glfwWindowShouldClose(window))
    {
        /* Render here */
        glClear(GL_COLOR_BUFFER_BIT);
        // f0();
        
        //f1_1();
        f2_1();

        /* Swap front and back buffers */
        glfwSwapBuffers(window);

        /* Poll for and process events */
        glfwPollEvents();
    }

    glDeleteProgram(shader);

    glfwTerminate();
    return 0;
}
```



### Dealing with Errors in OpenGL

æ£€æŸ¥é”™è¯¯

- `glGetError`ï¼Œä¸æ–­è°ƒç”¨ä»¥è·å¾—å…¨éƒ¨çš„é”™è¯¯æ ‡è¯†
  - > - If more than one flag has recorded an error, **`glGetError`** returns and clears an arbitrary error flag value. Thus, **`glGetError`** should always be called in a loop, until it returns `GL_NO_ERROR`, if all error flags are to be reset.
- `glDebugMessageCallBack` >= OpenGL 4.3
  - å…è®¸æˆ‘ä»¬æŒ‡å®šä¸€ä¸ªæŒ‡å‘ OpenGL çš„å‡½æ•°æŒ‡é’ˆ

æ–­è¨€

å®

```C++
/**
1 __debugbread() æ˜¯ window å¹³å°çš„ç‰¹æ€§
2 å®å±€é™æ€§ï¼Œeg.
{ int a = 10; int b = a + 10}
int c = a + b; // a and b is out of scope
æ‰€ä»¥ï¼Œåœ¨ä½¿ç”¨ GLCall åŒ…è£¹å‡½æ•°çš„åœ°æ–¹ï¼Œæ³¨æ„ä½œç”¨åŸŸæå‡ï¼ï¼ï¼
3 ä½¿ç”¨ do while åŒ…è£¹ï¼Œæ˜¯ä¸ºäº†é¿å…å†…éƒ¨å‡ºç° if ç­‰æ¡ä»¶è¯­å¥ï¼Œä¸­æ–­äº†ä»£ç æ‰§è¡Œ
*/
#define ASSERT(x) if (!(x)) __debugbreak();
#define GLCall(x) do { \
    GLClearError();\
    x;\
    ASSERT(GLLogCall(#x, __FILE__, __LINE__));\
} while (0)

static void GLClearError()
{
    while (glGetError() != GL_NO_ERROR);
}

static bool GLLogCall(const char* function, const char* file, int line)
{
    while (GLenum error = glGetError())
    {
        std::cout << "[OpenGL Error] (" << std::hex << error << "): " << function << "  " << file << ":" << std::dec << line << std::endl;
        return false;
    }
    return true;
}

// ä½¿ç”¨
// GLCall(glDrawElements(GL_TRIANGLES, 6, GL_INT, nullptr));
```

### Uniforms in OpenGL

ä» CPU åˆ° GPU

- ç»Ÿä¸€å˜é‡ï¼Œæ˜¯è®¾ç½®æ¯æ¬¡ç»˜åˆ¶çš„
- å±æ€§ï¼Œæ˜¯è®¾ç½®æ¯ä¸ªé¡¶ç‚¹

é€šè¿‡ä½¿ç”¨å®é™…çš„ç€è‰²å™¨idï¼Œç¼–å†™ glUserProgram æ¥ç»‘å®šç€è‰²å™¨ï¼Œè·å–è¿™ä¸ªå®é™…é¢œè‰²å˜é‡çš„ä½ç½®ã€‚

```C++
{
    int location = glGetUniformLocation(shader, "u_Color");
    ASSERT(location != -1);
    
    GLCall(glUniform4f(location, 0.2, 0.3, 0.8, 1.0));
}

{
#shader fragment
#version 330 core

layout(location = 0) out vec4 color;
uniform vec4 u_Color;

void main()
{
   //color = vec4(0.2, 0.3, 0.8, 1.0);
   color = u_Color;
};
}
```

### Vertex Arrays in OpenGL

é¡¶ç‚¹æ•°ç»„ï¼ŒOpenGL ç‰¹æœ‰ï¼Œæ˜¯ä¸€ç§é€šè¿‡ä¸€ç§ç‰¹å®šçš„è§„èŒƒç»‘å®šé¡¶ç‚¹ç¼“å†²åŒºçš„æ–¹å¼ã€‚

é¡¶ç‚¹æ•°ç»„å¯¹è±¡å°†åŒ…å«é¡¶ç‚¹ç¼“å†²åŒºä¹‹é—´çš„ç»‘å®šä»¥åŠå®é™…çš„é¡¶ç‚¹è§„èŒƒæˆ–é¡¶ç‚¹åˆ°å¸ƒå±€ã€‚

```Plain
ç»‘å®šé¡¶ç‚¹ç¼“å†²åŒº --> æŒ‡å®šå¸ƒå±€
ç»‘å®šç´¢å¼•ç¼“å†²åŒº
ç„¶åç»˜åˆ¶å®é™…çš„å¯¹è±¡
ç»‘å®šç€è‰²å™¨
ç»‘å®šé¡¶ç‚¹ç¼“å†²åŒº
è®¾ç½®é¡¶ç‚¹å¸ƒå±€
ç»‘å®šç´¢å¼•ç¼“å†²åŒº
ç„¶åå‘å‡º DrawCall æŒ‡ä»¤
---
ç»‘å®šç€è‰²å™¨
ç»‘å®šé¡¶ç‚¹æ•°ç»„
ç»‘å®šç´¢å¼•ç¼“å†²åŒº
ç„¶åå‘å‡º DrawCall æŒ‡ä»¤
```

vertexAttribPointer å®é™…ä¸Šä¼šç»‘å®šä¸€ä¸ªå®é™…çš„é¡¶ç‚¹ç¼“å†²åŒºå’Œæ•°ç»„ç¼“å†²åŒºã€‚

![img](../../assets/glvertexattribpointer-vao.png)



1. å¯ä»¥åœ¨æ•´ä¸ªé¡¹ç›®ä¸­æœ‰ä¸€ä¸ª å…¨å±€ VAOï¼Œç„¶åæ¯æ¬¡ç»‘å®šä¸åŒçš„ç¼“å†²åŒºå’Œä¸åŒçš„é¡¶ç‚¹è§„èŒƒã€‚
2. å¯¹æ¯ä¸ªå‡ ä½•ä½“æˆ–å”¯ä¸€å‡ ä½•ä½“æˆ–ä»»ä½•ä¸œè¥¿éƒ½æœ‰å•ç‹¬çš„VAO

```C++
#if 1
#include <iostream>
#include <GL/glew.h>
#include "GLFW/glfw3.h"
#include <fstream>
#include <string>
#include <sstream>

#define ASSERT(x) if (!(x)) __debugbreak();
#define GLCall(x) do { \
    GLClearError();\
    x;\
    ASSERT(GLLogCall(#x, __FILE__, __LINE__));\
} while (0)

static void GLClearError()
{
    while (glGetError() != GL_NO_ERROR);
}

static bool GLLogCall(const char* function, const char* file, int line)
{
    while (GLenum error = glGetError())
    {
        std::cout << "[OpenGL Error] (" << std::hex << error << "): " << function << "  " << file << ":" << std::dec << line << std::endl;
        return false;
    }
    return true;
}

struct ShaderProgramSource
{
    std::string VertexSource;
    std::string FragmentSource;
};

static ShaderProgramSource ParseShader(const std::string& filePath)
{
    std::ifstream infile(filePath);
    if (!infile)
    {
        std::cout << "Error opening file \n";
    }

    enum class ShaderType
    {
        NONE = -1, VERTEX = 0, FRAGMENT = 1
    };
    
    std::string line;
    // for vertex shader and fragment shader
    std::stringstream ss[2];
    ShaderType type = ShaderType::NONE;

    while (std::getline(infile, line)) {
        if (line.find("#shader") != std::string::npos)
        {
            if (line.find("vertex") != std::string::npos)
            {
                type = ShaderType::VERTEX;
            }
            else if (line.find("fragment") != std::string::npos)
            {
                type = ShaderType::FRAGMENT;
            }
        }
        else
        {
            ss[(int)type] << line << '\n';
        }
        
    }
    infile.close();

    return {ss[0].str(), ss[1].str()};
}

static unsigned int CompileShader(unsigned int type, const std::string& source)
{
    unsigned int id;
    GLCall(id = glCreateShader(type));
    const char* src = source.c_str();
    GLCall(glShaderSource(id, 1, &src, nullptr));
    GLCall(glCompileShader(id));

    // TODO: Error handling
    int result;
    GLCall(glGetShaderiv(id, GL_COMPILE_STATUS, &result));
    if (result == GL_FALSE)
    {
        int length;
        GLCall(glGetShaderiv(id, GL_INFO_LOG_LENGTH, &length));
        char* message = (char*)alloca(length * sizeof(char));
        GLCall(glGetShaderInfoLog(id, length, &length, message));
        std::cout << "Failed  to Compile " <<
            (type == GL_VERTEX_SHADER ? "vertex" : "fragment") << "shader ! " << message << std::endl;
        GLCall(glDeleteShader(id));
        return 0;
    }

    return id;
}

static int CreateShader(const std::string& vertexShader, const std::string& fragmentShader)
{
    unsigned int program;
    GLCall(program = glCreateProgram());
    unsigned int vs = CompileShader(GL_VERTEX_SHADER, vertexShader);
    unsigned int fs = CompileShader(GL_FRAGMENT_SHADER, fragmentShader);

    // attach
    GLCall(glAttachShader(program, vs));
    GLCall(glAttachShader(program, fs));
    // link
    GLCall(glLinkProgram(program));
    // valid
    GLCall(glValidateProgram(program));

    GLCall(glDeleteShader(vs));
    GLCall(glDeleteShader(fs));

    return program;
}


int main()
{
    GLFWwindow* window;

    /* Initialize the library */
    if (!glfwInit())
        return -1;

    // version 3.3 Core profile
    glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 3);
    glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 3);
    glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);

    /* Create a windowed mode window and its OpenGL context */
    window = glfwCreateWindow(640, 480, "Hello World", NULL, NULL);
    if (!window)
    {
        glfwTerminate();
        return -1;
    }

    /* Make the window's context current */
    glfwMakeContextCurrent(window);

    glfwSwapInterval(1);

    GLenum err = glewInit();
    if (GLEW_OK != err)
    {
        /* Problem: glewInit failed, something is seriously wrong. */
        fprintf(stderr, "Error: %s\n", glewGetErrorString(err));

    }

    std::cout << glGetString(GL_VERSION) << std::endl;

    // use index buffer
    float positions[12] = {
        -0.5f, -0.5f,
         0.5f, -0.5f,
         0.5f,  0.5f,
        -0.5f,  0.5f
    };

    unsigned int indices[] = {
        0, 1, 2,
        2, 3, 0
    };

    unsigned int vao;
    GLCall(glGenVertexArrays(1, &vao));
    GLCall(glBindVertexArray(vao));

    unsigned int buffer;
    GLCall(glGenBuffers(1, &buffer));
    GLCall(glBindBuffer(GL_ARRAY_BUFFER, buffer));
    GLCall(glBufferData(GL_ARRAY_BUFFER, 4 * 2 * sizeof(float), positions, GL_STATIC_DRAW));

    GLCall(glEnableVertexAttribArray(0));
    // 0 is going to actually be bound to the currently bound GL_ARRAY_BUFFER
    GLCall(glVertexAttribPointer(0, 2, GL_FLOAT, GL_FALSE, sizeof(float) * 2, (const void*)0));

    unsigned int ibo;
    GLCall(glGenBuffers(1, &ibo));
    GLCall(glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, ibo));
    GLCall(glBufferData(GL_ELEMENT_ARRAY_BUFFER, 6 * sizeof(unsigned int), indices, GL_STATIC_DRAW));

    ShaderProgramSource source = ParseShader("res/shaders/Basic.shader");
    std::cout << "VertexSource" << std::endl;
    std::cout << source.VertexSource << std::endl;
    std::cout << "FragmentSource" << std::endl;
    std::cout << source.FragmentSource << std::endl;
    unsigned int shader = CreateShader(source.VertexSource, source.FragmentSource);
    GLCall(glUseProgram(shader));

    int location;
    GLCall(location = glGetUniformLocation(shader, "u_Color"));
    ASSERT(location != -1);

    GLCall(glUniform4f(location, 0.6f, 0.3f, 0.8f, 1.0f));

    GLCall(glBindVertexArray(0));
    GLCall(glUseProgram(0));
    GLCall(glBindBuffer(GL_ARRAY_BUFFER, 0));
    GLCall(glBindBuffer(GL_ARRAY_BUFFER, 0));

    float r = 0.0f;
    float increment = 0.05f;

    /* Loop until the user closes the window */
    while (!glfwWindowShouldClose(window))
    {
        /* Render here */
        GLCall(glClear(GL_COLOR_BUFFER_BIT));

        GLCall(glUseProgram(shader));
        GLCall(glUniform4f(location, r, 0.3f, 0.8f, 1.0f));

        //GLCall(glBindBuffer(GL_ARRAY_BUFFER, buffer));
        //GLCall(glEnableVertexAttribArray(0));
        //GLCall(glVertexAttribPointer(0, 2, GL_FLOAT, GL_FALSE, sizeof(float) * 2, 0));
        GLCall(glBindVertexArray(vao));
        GLCall(glBindBuffer( GL_ELEMENT_ARRAY_BUFFER, ibo));

        GLCall(glDrawElements(GL_TRIANGLES, 6, GL_UNSIGNED_INT, nullptr));

        if (r > 1.0f)
            increment = -0.05f;
        else if (r < 0.0f)
            increment = 0.05f;

        r += increment;

        /* Swap front and back buffers */
        GLCall(glfwSwapBuffers(window));

        /* Poll for and process events */
        GLCall(glfwPollEvents());
    }

    GLCall(glDeleteProgram(shader));

    glfwTerminate();
    return 0;
}
#endif
```



ä½¿ç”¨æ ¸å¿ƒé…ç½®æ–‡ä»¶å¿…é¡»åˆ›å»ºä¸€ä¸ªé¡¶ç‚¹æ•°ç»„å¯¹è±¡

ä½¿ç”¨å…¼å®¹æ€§é…ç½®æ–‡ä»¶ï¼Œæ¡†æ¶æœ‰ä¸€ä¸ªé»˜è®¤çš„é¡¶ç‚¹æ•°ç»„å¯¹è±¡ï¼Œå®ƒè¢«ç»‘å®šå¹¶è®¾ç½®ä¸ºä¾›æˆ‘ä»¬ä½¿ç”¨ã€‚

A. ä½¿ç”¨å…¼å®¹æ€§é…ç½®æ–‡ä»¶å’Œé»˜è®¤é¡¶ç‚¹æ•°ç»„ï¼Œç»‘å®šé¡¶ç‚¹ç¼“å†²åŒºï¼Œè®¾ç½®é¡¶ç‚¹å¸ƒå±€

B. ä½¿ç”¨æ ¸å¿ƒé…ç½®æ–‡ä»¶ï¼Œåˆ›å»ºé¡¶ç‚¹æ•°ç»„ï¼Œç»‘å®šé¡¶ç‚¹æ•°ç»„

B.1 é¡¶ç‚¹æ•°ç»„å¯ä»¥æ˜¯ä¸€ä¸ªå…¨å±€çš„

B.2 é¡¶ç‚¹æ•°ç»„å¯ä»¥æ˜¯å¤šä¸ª

### Abstracting OpenGL into Classes

render

Vertex attribute stuff

Shader

Index buffer

textures

### Buffer  layout Abstraction in OpenGL

æˆ‘å·²æŠŠä»£ç æäº¤åˆ°  [GitHub - likenow/OpenGLDemo](https://github.com/likenow/OpenGLDemo)

ä¸¤ç‚¹è®°å½•ï¼š

1. Visual Studio 2022æäº¤ä»£ç çš„æ—¶å€™ï¼Œæç¤º "your solution contains files outside the solution folder which will not be included."  æˆ‘æ²¡ç®¡ç›´æ¥æäº¤äº†
2. åœ¨å†™ä»£ç çš„è¿‡ç¨‹ä¸­ï¼Œæˆ‘æŠŠ VertexBufferElement ç»“æ„ä½“çš„æˆå…ƒå˜é‡é¡ºåºå†™çš„å’Œè§†é¢‘é‡Œä¸ä¸€è‡´ï¼Œç»“æœå°±æŠ¥é”™ï¼Œæ‰¾äº†å¥½ä¸€ä¼šå„¿ï¼Œç‰¹æ­¤è®°å½•ï¼ï¼ï¼

![img](../../assets/2023-4-15-vertexbufferelement.png)

### Shader Abstraction in OpenGL

ç€è‰²å™¨å¯ä»¥æ˜¯ä¸€ä¸ªå¤æ‚çš„ç³»ç»Ÿ

åˆ›å»ºä¸€äº›æ¨¡ç‰ˆåŒ–çš„ä¸œè¥¿

### Writing a Basic Render in OpenGL

Material instead of an actual shader

Material = shader + data

### Textures in OpenGL

çº¹ç†

In this case, texture thinks as essentially an image that we can use

å¤æ‚çš„ï¼Œæ¯”å¦‚ä½¿ç”¨é¢„å…ˆè®¡ç®—å¥½çš„æ•°å­¦å€¼ï¼Œå°†å…¶èå…¥åˆ°çº¹ç†ä¸­ï¼Œç„¶ååœ¨ç€è‰²å™¨ä¸­å¯¹ä»–ä»¬è¿›è¡Œé‡‡æ ·ï¼Œè¿™æ ·å¯ä»¥åšä¸€äº›å¾ˆé…·çš„æ•ˆæœ

stb_image åº“

åŠ è½½ PNG å›¾ç‰‡ï¼Œç»™å®ƒä¸€ä¸ªæ–‡ä»¶è·¯å¾„ï¼Œå®ƒä¼šç»™æˆ‘ä¸€ä¸ªæŒ‡å‘RGBAåƒç´ ç¼“å†²åŒºçš„æŒ‡é’ˆ

æˆ‘ä¼šå–é‚£ä¸ªåƒç´ æ•°ç»„ï¼Œç„¶åæŠŠå®ƒä¼ åˆ°æˆ‘ä»¬çš„æ˜¾å¡ï¼Œä½¿ç”¨OpenGL ç„¶åæŠŠæ•°æ®ä½œä¸ºçº¹ç†å‘é€åˆ°æ˜¾å¡

åœ¨ç»˜åˆ¶æ—¶ï¼Œå¯ä»¥ä½¿ç”¨ç€è‰²å™¨æ¥è¯»å–å“ªä¸ªçº¹ç†ï¼Œç‰‡æ®µç€è‰²å™¨ä¼šä»çº¹ç†å†…å­˜ä¸­è¯»å–å¹¶å®é™…è®¡ç®—å‡ºæ¯ä¸ªåƒç´ åº”è¯¥æ˜¯ä»€ä¹ˆï¼Œæ„æˆé‚£ä¸ªçº¹ç†æ¯éƒ¨åˆ†çš„é¢œè‰²æ˜¯ä»€ä¹ˆã€‚

æ€»ç»“ï¼š

åŠ è½½å›¾ç‰‡

åœ¨OpenGL ä¸­åˆ›å»ºçº¹ç†

æ¸²æŸ“æ—¶ç»‘å®šçº¹ç†

ä¿®æ”¹ç€è‰²å™¨æ¥ç»‘å®šåˆ°é‚£ä¸ªçº¹ç†æ’æ§½

ç€è‰²å™¨é‡‡æ ·

åœ¨é¡¶ç‚¹å’Œç‰‡æ®µç€è‰²å™¨ä¹‹é—´å‘é€æ•°æ®çš„æ–¹å¼ã€‚ -- Varying

```C++
#shader vertex
#version 330 core

layout(location = 0) in vec4 position;
layout(location = 1) in vec2 texCoord;

// varying
out vec2 v_TexCoord;

void main()
{
   gl_Position = position;
   v_TexCoord = texCoord;
};

#shader fragment
#version 330 core

layout(location = 0) out vec4 color;

in vec2 v_TexCoord;

uniform vec4 u_Color;
uniform sampler2D u_Texture;

void main()
{
    // å¯¹ç‰¹å®šçº¹ç†åæ ‡è¿›è¡Œé‡‡æ ·
    vec4 texColor = texture(u_Texture, v_TexCoord);
    //color = vec4(0.2, 0.3, 0.8, 1.0);
    color = texColor;
};
```

ç‰‡æ®µç€è‰²å™¨ä¸ºæ¯ä¸ªåƒç´ è¿è¡Œï¼Œæ‰€ä»¥éœ€è¦çŸ¥é“çº¹ç†ä¸­çš„ç²¾ç¡®ä½ç½®æ¥æŸ¥æ‰¾ï¼Œè¿™æ ·æˆ‘ä»¬å°±å¯ä»¥åœ¨å®é™…å±å¹•ä¸­ä»çº¹ç†ä¸­ç»˜åˆ¶å‡ºé‚£ä¸ªåƒç´ 



### Blending in OpenGL

Determines how we combine our output color with what is already in our target buffer.

Output = the color we output from our fragment shader (know as source)

Target buffer = the buffer our fragment shader is drawing to (know as destination)

1. glEnable(GL_BLEND) - glDisable(GL_BLEND)
2. glBlendFunc(src, dest) src ç›¸å½“äº ps çš„ä¸Šå›¾å±‚ï¼Œ dest ç›¸å½“äºä¸‹å›¾å±‚
   1. Src = how the src RGBA factor is computed(default is GL_ONE)
   2. Dest = how the dest RGBA factor is computed(default is GL_ZERO)
   3.  é»˜è®¤çš„ glGenBlendFunc å‚æ•°ï¼Œä¼šä¸¢æ‰ destï¼Œç”¨ src è¦†ç›–å®ƒ
3. glBlendEquation(mode)
   1. Mode = how we combine the src and dest colors(default is GL_FUNC_ADD)
   2.  So that means by default is : 1+ 0 = 1

Src = GL_SRC_ALPHA

Dest = GL_ONE_MINUS_SRC_ALPHA

```C++
{
    GLCall(glEnable(GL_BLEND));
    GLCall(glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA));
}
```

==>

src alpha = 0

dest = 1 - 0 = 1

```C++
R = (Rsrc * 0) + (Rdest * (1-0)) = Rdest
G = (Gsrc * 0) + (Gdest * (1-0)) = Gdest
B = (Bsrc * 0) + (Bdest * (1-0)) = Bdest
A = (Asrc * 0) + (Adest * (1-0)) = Adest
```

Eg.

(1.0, 1.0, 1.0, 0.5)

(1.0, 0.0, 1.0, 1.0)

Blending:

```C++
R = (1.0 * 0.5) + (1.0 * (1-0.5)) = 1.0
G = (1.0 * 0.5) + (0.0 * (1-0.5)) = 0.5
B = (1.0 * 0.5) + (1.0 * (1-0.5)) = 1.0
A = (0.5 * 0.5) + (1.0 * (1-0.5)) = 0.75
```

æ··åˆ

é€æ˜

### Maths in OpenGL

æ•°å­¦

çŸ©é˜µ matrixes

å‘é‡ vectors

å˜æ¢ transformation

æ•°å­¦åº“ï¼š[Releases Â· g-truc/glm](https://github.com/g-truc/glm/releases)

### Projection Matrices in OpenGL

Projection matrix æŠ•å½±çŸ©é˜µ

How we go from having some kind of arbitrary coordinate system in our 3D world or 2D world

How we go from having coordinates or vertex positions in that space to being able to somehow map them to our window. So we have to project them somehow onto this to surface.

> It is essentially the maths that converts all of those 3D points in space into something that is in a 2D kind of window.

Some kind of normalized space that we can, then map to our window.

A normalized space means that literally a coordinate system between -1 and 1 in every axis x,y,z.

Orthographic

Usually 2D

Perspective

Usually 3D

Projection converts it into normal device coordinate space of -1 to 1. That's relly all that's happening. 

```C++
#shader vertex
#version 330 core

layout(location = 0) in vec4 position;
layout(location = 1) in vec2 texCoord;

out vec2 v_TexCoord;

uniform mat4 u_MVP;

void main()
{
   // è¿™é‡Œæ³¨æ„âš ï¸çŸ©é˜µç›¸ä¹˜æœ‰é¡ºåºâ—ï¸  u_MVP * position âŒ position * u_MVP 
   gl_Position = u_MVP * position;
   v_TexCoord = texCoord;
};

#shader fragment
#version 330 core

layout(location = 0) out vec4 color;

in vec2 v_TexCoord;

uniform vec4 u_Color;
uniform sampler2D u_Texture;

void main()
{
        vec4 texColor = texture(u_Texture, v_TexCoord);
   //color = vec4(0.2, 0.3, 0.8, 1.0);
   color = texColor;
};
```

### Model View Projection Matrices in OpenGL

æ¨¡å‹çŸ©é˜µ model matrix -- å¯¹è±¡å˜æ¢ï¼ˆpositionä½ç½®/ rotationæ—‹è½¬/ scaleç¼©æ”¾/ translationå¹³ç§»...ï¼‰

è§†å›¾çŸ©é˜µ view matrix -- è§†è§‰çŸ©é˜µ -- â€œç›¸æœºçš„è§†å›¾ï¼Œä½ç½®/æ–¹å‘â€

Projection matrix æŠ•å½±çŸ©é˜µ

==> MVP ==> è¿™ä¸‰ä¸ªçŸ©é˜µå®šä¹‰äº†é¡¶ç‚¹ä½ç½®çš„ä¸åŒä¸œè¥¿ã€‚

That all of that gets multiplied together with ours with each vertex position to give us kind of the final position of the vertex in our actual screen.like on inside our window, or in our kind of 2d projection that is on our computer screen.

æ‰€æœ‰è¿™äº›ï¼ˆMVPï¼‰å’Œæ¯ä¸ªé¡¶ç‚¹ä½ç½®ç›¸ä¹˜ï¼Œè®¡ç®—å‡ºæˆ‘ä»¬é¡¶ç‚¹åœ¨å®é™…å±å¹•ä¸­çš„æœ€ç»ˆä½ç½®ï¼Œæ¯”å¦‚çª—å£å†…éƒ¨ï¼Œæˆ–è€…ç”µè„‘å±å¹•ä¸Šçš„2dæŠ•å½±ã€‚

åœ¨ OpenGL ä¸­æ˜¯ `P*V*M`



### ImGui in OpenGL

é›†æˆ [imgui](https://github.com/ocornut/imgui/releases) 1.89.5

![img](../../assets/2023-4-17-imgui-file-category.png)

```Shell
Build started...
1>------ Build started: Project: DemoLibrary, Configuration: Debug x64 ------
1>imgui.cpp
1>imgui_demo.cpp
1>imgui_draw.cpp
1>imgui_impl_glfw.cpp
1>imgui_impl_opengl3.cpp
1>imgui_tables.cpp
1>imgui_widgets.cpp
1>Generating Code...
1>glew32s.lib(glew.obj) : warning LNK4099: PDB '' was not found with 'glew32s.lib(glew.obj)' or at ''; linking object as if no debug info
1>LINK : warning LNK4098: defaultlib 'MSVCRT' conflicts with use of other libs; use /NODEFAULTLIB:library
1>LINK : warning LNK4098: defaultlib 'LIBCMT' conflicts with use of other libs; use /NODEFAULTLIB:library
1>DemoLibrary.vcxproj -> C:\Users\fmsli\dev\DemoLibrary\bin\x64\Debug\DemoLibrary.exe
1>Done building project "DemoLibrary.vcxproj".
========== Build: 1 succeeded, 0 failed, 0 up-to-date, 0 skipped ==========
========== Build started at 8:31 PM and took 04.298 seconds ==========
```

### Rendering Multiple Objects in OpenGL

æ‰¹é‡æ¸²æŸ“å¯¹è±¡

æ¸²æŸ“ä¸€ä¸ªæ–°çš„ logo å›¾åˆ°æ–°çš„ä½ç½®ï¼Œä¸¤ç§æ–¹æ³•ï¼š

- æ”¹å˜å±æ€§å’Œé¡¶ç‚¹ç¼“å†²åŒºï¼ˆpositionsï¼‰
- æ”¹å˜æ¨¡å‹è§†å›¾æŠ•å½±çŸ©é˜µç»Ÿä¸€å˜é‡ï¼ˆmatrix uniformï¼‰

### Setting up a Test Framework for OpenGL

å»ºç«‹ä¸€ä¸ªæµ‹è¯•æ¡†æ¶

### Creating Tests in OpenGL

Menu -- imgui èœå•

Command line with argument -- å‘½ä»¤è¡Œ

### Creating a Texture Test in OpenGL

ä½¿ç”¨äº†æ™ºèƒ½æŒ‡é’ˆæŒæœ‰

```C++
namespace test {
    class TestTexture2D : public Test
    {
    public:
        TestTexture2D();
        ~TestTexture2D();

        void OnUpdate(float deltaTime) override;
        void OnRender() override;
        void OnImGuiRender() override;
    private:
        std::unique_ptr<VertexArray> m_VAO;
        std::unique_ptr<IndexBuffer> m_IndexBuffer;
        std::unique_ptr<VertexBuffer> m_VertexBuffer;
        std::unique_ptr<Shader> m_Shader;
        std::unique_ptr<Texture> m_Texture;

        glm::mat4 m_Proj, m_View;
        glm::vec3 m_TranslationA, m_TranslationB;
    };
}
```