## OpenGL

[toc]



> Thanks https://youtube.com/playlist?list=PLlrATfBNZ98foTJPJ_Ev03o2oq3-GGOS2 Cherno

### welcome

OpenGL is just a spec(specification), cross-platform

AMD Intel ... So everyone's implementation of OpenGL is gonna be slightly different

Legacy opengl

Modern Opengl

### Setting up OpenGL and Creating a Window in C++

GLFW

What you compile your application with, so we'll just be using a 32-bit application because we don't need a 64-bit one

添加依赖库



```c++
❌
LNK2019
unresolved external symbol __imp_glClear referenced in function main

What link is trying to do now is find a definition for 
that glClear Function That is inside an opengl library file
so we actuall have to link against that.

Project --> Properties --> Linker --> input --> additional dependencies
opengl32.lib;
```



代码：

```c++

#include <iostream>
#include "GLFW/glfw3.h"

int main()
{
    GLFWwindow* window;

    /* Initialize the library */
    if (!glfwInit())
        return -1;

    /* Create a windowed mode window and its OpenGL context */
    window = glfwCreateWindow(640, 480, "Hello World", NULL, NULL);
    if (!window)
    {
        glfwTerminate();
        return -1;
    }

    /* Make the window's context current */
    glfwMakeContextCurrent(window);

    /* Loop until the user closes the window */
    while (!glfwWindowShouldClose(window))
    {
        /* Render here */
        glClear(GL_COLOR_BUFFER_BIT);

        glBegin(GL_TRIANGLES);
        
        // draw a triangle
        glVertex2f(-0.5f, -0.5f);
        glVertex2f(0.0f, 0.5f);
        glVertex2f(0.5f, -0.5f);

        glEnd();

        /* Swap front and back buffers */
        glfwSwapBuffers(window);

        /* Poll for and process events */
        glfwPollEvents();
    }

    glfwTerminate();
    return 0;
}
```



### Using Modern OpenGL in C++

Pull out the functions and call them

Get  the function Declarations and then link against the functions as well

So we need to access the driver's DLL files and just retrieve the function pointers

to the functions inside those libraries . That's what we need to do.

#### [glew](https://glew.sourceforge.net/)

放到 `\Dependencies\GLEW` 目录下

添加新的静态库依赖

```c++
/*
Configuration    Platform
 C/  C++   --> General --> Additional include Directories （$(SolutionDir)Dependencies\GLEW\include）
 C/  C++   --> linker --> general --> Additional library directories（$(SolutionDir)Dependencies\GLEW\lib\Release\x64）
  (这里包含依赖库文件的根目录)  
 C/  C++   --> linker --> input --> Additional Dependencies ("glew32s.lib" for 32-bit builds, "glew32s.lib" for 64-bit builds)
  
  */

/*
❌
Build started...
1>------ Build started: Project: DemoLibrary, Configuration: Debug x64 ------
1>LINK : warning LNK4098: defaultlib 'MSVCRT' conflicts with use of other libs; use /NODEFAULTLIB:library
1>Main.obj : error LNK2019: unresolved external symbol __imp_glewInit referenced in function main
1>Main.obj : error LNK2019: unresolved external symbol __imp_glewGetErrorString referenced in function main
1>C:\Users\fmsli\dev\DemoLibrary\bin\x64\Debug\DemoLibrary.exe : fatal error LNK1120: 2 unresolved externals
1>Done building project "DemoLibrary.vcxproj" -- FAILED.
========== Build: 0 succeeded, 1 failed, 0 up-to-date, 0 skipped ==========
========== Build started at 6:52 PM and took 00.429 seconds ==========
#include <GL/glew.h> // 在 #include "GLFW/glfw3.h" 之前
  
  */

/*
 * GLEW_STATIC is defined for static library.
 * GLEW_BUILD  is defined for building the DLL library.
 
 C/  C++   --> Preprocessor --> Preprocessor Definitions --> GLEW_STATIC
 */
 
 
```



### Vertex Buffers and Drawing a Triangle in OpenGL

- Create a vertex **buffer** 创建一个顶点缓冲区
- Create a shader 创建一个着色器

State machine

Contextual 上下文相关的

Vertex attribute stuff

Shader

Index buffer

### Vertex Attritures and Layouts in OpenGL

顶点属性和布局

顶点不仅仅是位置！！！A vertex can contain way more than just a position!

属性：

- Position 位置
- Texture coordinate 纹理坐标
- Normal 法线

Index 索引

```C++
    // enable
    glEnableVertexAttribArray(0);
    /*
    stride 是每个顶点之间的字节数
    the stride is the amount of bytes that we have between each vertex

    pointer 是每个属性之间的字节数
    */
    glVertexAttribPointer(0, 2, GL_FLOAT, GL_FALSE, sizeof(float) * 2, (const void*)0);
    
```

平台提供默认着色器，不建议这样使用。

### How Shaders Work in OpenGL

**pipeline**

- Vertex shaders 
  - 顶点着色器 -- 指定了位置/ 转换（it specifies the way you want to on the positions to be）
- Fragment（pixel） shaders 
  - 片段着色器 rasterized 光栅化（对三角形中需要填充的每个像素调用一次）决定像素应该是什么颜色
- ... 还有很多着色器

### Writing a Shader in OpenGL

我会在编译期间把它（文本）打包进最终程序文件

```C++
static unsigned int CompileShader(unsigned int type, const std::string& source)
{
    unsigned int id = glCreateShader(type);
    const char* src = source.c_str();
    glShaderSource(id, 1, &src, nullptr);
    glCompileShader(id);

    // TODO: Error handling
    int result;
    glGetShaderiv(id, GL_COMPILE_STATUS, &result);
    if (result == GL_FALSE)
    {
        int length;
        glGetShaderiv(id, GL_INFO_LOG_LENGTH, &length);
        char* message = (char*)alloca(length * sizeof(char));
        glGetShaderInfoLog(id, length, &length, message);
        std::cout << "Failed  to Compile " <<
            (type == GL_VERTEX_SHADER ? "vertex" : "fragment") << "shader ! " << message << std::endl;
        glDeleteShader(id);
        return 0;
    }

    return id;
}

static int CreateShader(const std::string& vertexShader, const std::string& fragmentShader)
{
    unsigned int program = glCreateProgram();
    unsigned int vs = CompileShader(GL_VERTEX_SHADER, vertexShader);
    unsigned int fs = CompileShader(GL_FRAGMENT_SHADER, fragmentShader);

    // attach
    glAttachShader(program, vs);
    glAttachShader(program, fs);
    // link
    glLinkProgram(program);
    // valid
    glValidateProgram(program);

    glDeleteShader(vs);
    glDeleteShader(fs);
    // glDetach  -- pro operation

    return program;
}

void f2()
{
    // positions
    float positions[6] = {
        -0.5f, -0.5f,
         0.0f,  0.5f,
         0.5f, -0.5f
    };
    // this is the id of the generated buffer object
    unsigned int buffer;
    glGenBuffers(1, &buffer);
    // bindding buffer memory <--> buffer object
    glBindBuffer(GL_ARRAY_BUFFER, buffer);
    // specify the data
    glBufferData(GL_ARRAY_BUFFER, 6 * sizeof(float), positions, GL_STATIC_DRAW);

    // enable
    glEnableVertexAttribArray(0);
    // attribute
    glVertexAttribPointer(0, 2, GL_FLOAT, GL_FALSE, sizeof(float) * 2, (const void*)0);

    // bindding buffer memory <--> buffer object
    glBindBuffer(GL_ARRAY_BUFFER, 0);

    // shader
    std::string vertexShader = 
        "#version 330 core\n"
        "\n"
        "layout(location = 0) in vec4 position;"
        "\n"
        "void main()\n"
        "{\n"
        "   gl_Position = position;\n"
        "}\n";

    std::string fragmentShader =
        "#version 330 core\n"
        "\n"
        "layout(location = 0) out vec4 color;"
        "\n"
        "void main()\n"
        "{\n"
        "   color = vec4(1.0, 0.0, 0.0, 1.0);\n"
        "}\n";

    unsigned int shader = CreateShader(vertexShader, fragmentShader);
    glUseProgram(shader);
}
```

### How I Deal with Shaders in OpenGL

将两个着色器源码文件合并到一个文件中。从文件读取 shader

> Direct X is a Better API 🐶

Relative Path

```undefined
projects -> configuration  -> properties  -> debugging  -> working directory -> $(ProjectDir)
```

### Index Buffers in OpenGL

索引缓冲区

完全唯一的顶点

Same memory multiple times

重复冗余内存

必须是无符号内容

```C++
#include <fstream>
#include <string>
#include <sstream>

struct ShaderProgramSource
{
    std::string VertexSource;
    std::string FragmentSource;
};

static ShaderProgramSource ParseShader(const std::string& filePath)
{
    std::ifstream infile(filePath);
    if (!infile)
    {
        std::cout << "Error opening file \n";
    }

    enum class ShaderType
    {
        NONE = -1, VERTEX = 0, FRAGMENT = 1
    };
    
    std::string line;
    // for vertex shader and fragment shader
    std::stringstream ss[2];
    ShaderType type = ShaderType::NONE;

    while (std::getline(infile, line)) {
        if (line.find("#shader") != std::string::npos)
        {
            if (line.find("vertex") != std::string::npos)
            {
                type = ShaderType::VERTEX;
            }
            else if (line.find("fragment") != std::string::npos)
            {
                type = ShaderType::FRAGMENT;
            }
        }
        else
        {
            ss[(int)type] << line << '\n';
        }
        
    }
    infile.close();

    return {ss[0].str(), ss[1].str()};
}

static unsigned int CompileShader(unsigned int type, const std::string& source)
{
    unsigned int id = glCreateShader(type);
    const char* src = source.c_str();
    glShaderSource(id, 1, &src, nullptr);
    glCompileShader(id);

    // TODO: Error handling
    int result;
    glGetShaderiv(id, GL_COMPILE_STATUS, &result);
    if (result == GL_FALSE)
    {
        int length;
        glGetShaderiv(id, GL_INFO_LOG_LENGTH, &length);
        char* message = (char*)alloca(length * sizeof(char));
        glGetShaderInfoLog(id, length, &length, message);
        std::cout << "Failed  to Compile " <<
            (type == GL_VERTEX_SHADER ? "vertex" : "fragment") << "shader ! " << message << std::endl;
        glDeleteShader(id);
        return 0;
    }

    return id;
}

static int CreateShader(const std::string& vertexShader, const std::string& fragmentShader)
{
    unsigned int program = glCreateProgram();
    unsigned int vs = CompileShader(GL_VERTEX_SHADER, vertexShader);
    unsigned int fs = CompileShader(GL_FRAGMENT_SHADER, fragmentShader);

    // attach
    glAttachShader(program, vs);
    glAttachShader(program, fs);
    // link
    glLinkProgram(program);
    // valid
    glValidateProgram(program);

    glDeleteShader(vs);
    glDeleteShader(fs);

    return program;
}

unsigned int f2()
{
    // positions
    /*
    float positions[6] = {
        -0.5f, -0.5f,
         0.0f,  0.5f,
         0.5f, -0.5f
    };
    */
    /*
    // repeat and waste
    float positions[12] = {
        -0.5f, -0.5f,
         0.5f, -0.5f,
         0.5f,  0.5f,
         0.5f,  0.5f,
        -0.5f,  0.5f,
        -0.5f, -0.5f
    };
    */
    // use index buffer
    float positions[12] = {
        -0.5f, -0.5f,
         0.5f, -0.5f,
         0.5f,  0.5f,
        -0.5f,  0.5f
    };

    unsigned int indices[] = {
        0, 1, 2,
        2, 3, 0
    };

    // this is the id of the generated buffer object
    unsigned int buffer;
    glGenBuffers(1, &buffer);
    // bindding buffer memory <--> buffer object
    glBindBuffer(GL_ARRAY_BUFFER, buffer);
    // specify the data
    glBufferData(GL_ARRAY_BUFFER, 6 * 2 * sizeof(float), positions, GL_STATIC_DRAW);

    // enable
    glEnableVertexAttribArray(0);
    // attribute
    glVertexAttribPointer(0, 2, GL_FLOAT, GL_FALSE, sizeof(float) * 2, (const void*)0);

    unsigned int ibo;
    glGenBuffers(1, &ibo);
    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, ibo);
    glBufferData(GL_ELEMENT_ARRAY_BUFFER, 6 * sizeof(unsigned int), indices, GL_STATIC_DRAW);

    // bindding buffer memory <--> buffer object
    glBindBuffer(GL_ARRAY_BUFFER, 0);

    // relative path, which always from th working directory
    ShaderProgramSource source = ParseShader("res/shaders/Basic.shader");
    std::cout << "VertexSource" << std::endl;
    std::cout << source.VertexSource << std::endl;
    std::cout << "FragmentSource" << std::endl;
    std::cout << source.FragmentSource << std::endl;
    unsigned int shader = CreateShader(source.VertexSource, source.FragmentSource);
    glUseProgram(shader);
    return shader;
}

void f2_1()
{
    // 6 is in the index buffer
    // any index buffer has to be made up of unsigned int !!!
    glDrawElements(GL_TRIANGLES, 6, GL_UNSIGNED_INT, nullptr);
}
int main()
{
    GLFWwindow* window;

    /* Initialize the library */
    if (!glfwInit())
        return -1;

    /* Create a windowed mode window and its OpenGL context */
    window = glfwCreateWindow(640, 480, "Hello World", NULL, NULL);
    if (!window)
    {
        glfwTerminate();
        return -1;
    }

    /* Make the window's context current */
    glfwMakeContextCurrent(window);

    GLenum err = glewInit();
    if (GLEW_OK != err)
    {
        /* Problem: glewInit failed, something is seriously wrong. */
        fprintf(stderr, "Error: %s\n", glewGetErrorString(err));

    }

    // f1();

    unsigned int shader = f2();



    /* Loop until the user closes the window */
    while (!glfwWindowShouldClose(window))
    {
        /* Render here */
        glClear(GL_COLOR_BUFFER_BIT);
        // f0();
        
        //f1_1();
        f2_1();

        /* Swap front and back buffers */
        glfwSwapBuffers(window);

        /* Poll for and process events */
        glfwPollEvents();
    }

    glDeleteProgram(shader);

    glfwTerminate();
    return 0;
}
```



