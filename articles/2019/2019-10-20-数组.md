## 数组

### 概念

数组是一种线性表数据结构。它用一组**连续的内存空间**，来存储一组具有**相同类型**的数组。

利用元素的 **索引** 可以计算出该元素对应的存储地址。

我们常见到的数据结构类型是 **一维数组**。除此之外还有**多维数组**，比如：二维数组，对应数学上的 **矩阵**。

> **线性表**（Linear List）
>
> 是由n（n≥0）个[数据](https://zh.wikipedia.org/wiki/数据)元素（[结点](https://zh.wikipedia.org/w/index.php?title=结点&action=edit&redlink=1)）a[0]，a[1]，a[2]…，a[n-1]组成的[有限序列](https://zh.wikipedia.org/w/index.php?title=有限序列&action=edit&redlink=1)。
>
> 其中：
>
> - 数据元素的个数n定义为表的长度 = list.length() （list.length() = 0（表里没有一个元素）时称为空表）
> - 将非空的线性表（n>=1）记作：（a[0]，a[1]，a[2]，…，a[n-1]）
> - 数据元素a[i]（0≤i≤n-1）只是个抽象符号，其具体含义在不同情况下可以不同
>
> 一个数据元素可以由若干个数据项组成。数据元素称为**记录**，含有大量记录的线性表又称为**文件**。这种结构具有下列特点：存在一个唯一的没有前驱的（头）数据元素；存在一个唯一的没有后继的（尾）数据元素；此外，每一个数据元素均有一个直接前驱和一个直接后继数据元素。 　　


#### 随机访问

<img src="../assets/image-20201215105650110.png" alt="image-20201215105650110" style="zoom:50%;" />



如图，给`a[10]` 分配了一块连续的内存空间 `1000-1039` ，其中内存块的首地址为` base_address = 1000`。第i个元素的存储地址为：

`a[i]_address = base_address + i * data_type_size`

`data_type_size` 表示数组中每个元素的大小。例如：数组中存储的 int 类型的数据，32 位和 64位 编译器下均为 4个字节。



> ##### 问题：数组下标为什么要从0开始编号，而不是1开始呢？
>
> 从数组的模型上来看的话，**下标**确切的定义应该是**偏移(offset)**.也就是说，如果用`a`来表示数组的话，`a[0]`就表示偏移为0的位置，也就是首地址，`a[k]`就表示偏移为`k`个`type_size`的位置，所以计算`a[k]`的内存地址只需要使用下面的这个公式即可：
>
> 　　**a[k]_address = base_address + k \* type_size**
>
> 　　如果是从1开始编号的话，那么计算数组元素`a[k]`的内存地址就成了：
>
> 　　**a[k]_address = base_address + (k-1) \* type_size**
>
> 　　**对于当中的参数的含义，base_address:数组的首地址（上图表示的1000），k表示的则是数组的下标，type_size则表示数组存储的数据的大小，如果存储的是一个int型的数据，那么就是4字节。**
>
> 　　对比上面两个公式，可以发现如果从1开始编号，每次随机访问数组元素都多了一次**减法运算**，对于CPU来说的话，那就是多了一次指令。数组作为非常基础的数据结构，通过下标随机访问数组元素有事非常基础的编程操作，效率的优化就要尽可能的做到极致。所以为了减少一次减法操作，数组选择了从0开始编号，而不是从1开始编号。
>

### 数组操作

根据上述，数组支持随机访问，根据下标随机访问的时间复杂度为 O(1)。数组为了保持内存数据的连续性，会导致插入和删除 操作的低效。

#### 插入

- 数组头插入

  这种情况下，所有元素都要往后挪一位，最坏时间复杂度 O(n)

  <img src="../assets/image-20201215113236506.png" alt="image-20201215113236506" style="zoom:50%;" />

- 数组中间插入

  在该种情况下，如果要将某个元素插入到数组中的第k个位置，就必须按照上一种方式搬移k之后的数据。该种情况下数据插入的**最坏**时间复杂度为O(n)。

  <img src="../assets/image-20201215113806814.png" alt="image-20201215113806814" style="zoom:50%;" />

  **但是如果说，数组只是被用来当做一个存储集合，而不考虑数组中数据的顺序的话，为了避免大规模的数据搬移操作，有一个简单的办法，就是直接将第k个位置的数据搬移到数组的最后，然后将新元素直接放到第k个位置**

  <img src="../assets/image-20201215114034405.png" alt="image-20201215114034405" style="zoom:50%;" />

- 数组尾插入

  元素插入的时间复杂度为O(1)。不需要移动元素

<img src="../assets/image-20201215114214578.png" alt="image-20201215114214578" style="zoom:50%;" />

#### 删除

同插入操作一样，删除也分为三种：

- 头部删除

  最坏时间复杂度 O(n)

- 中间删除

  最坏时间复杂度 O(n)

- 尾部删除

  不需要移动元素，时间复杂度 O(1)

**但是有时候，我们并不一定非得要追求数组的连续性。如果我们将多次删除操作集中在一起执行，删除的效率是不是会提高很多呢？**

eg. 现有数组`a[10]` 存储了7个元素：A B C D E F G，现在要依次删除 A B C。为了避免数据 D E F G 多次搬移（其实是3次）。每次删除操作并不是真的搬移元素，只是标记为已被删除。当数组没有更多空间时，再出发依次真正的删除操作，这样就大大减少了删除操作导致的元素搬移。

<img src="../assets/image-20201215135421847.png" alt="image-20201215135421847" style="zoom:50%;" />





