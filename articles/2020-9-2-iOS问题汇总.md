## iOS é—®é¢˜

### 1. å‘ç‰ˆé—®é¢˜

1. ç‰ˆæœ¬å‘½åé—®é¢˜

<img src="../assets/operationError.png" alt="æˆªå±2020-04-23 ä¸‹åˆ4.31.04" style="zoom:50%;" />



> ERROR ITMS-90060: "This bundle is invalid. The value for key CFBundleShortVersionString '9.3.1.0' in the Info.plist file at 'Payload/Koala.app' must be a period-separated list of at most three non-negative integers. Please find more information about CFBundleShortVersionString at https://developer.apple.com/documentation/bundleresources/information_property_list/cfbundleshortversionstring"

#### è§£å†³åŠæ³•

åŸºæœ¬å®ç°æ€è·¯ï¼š

æ·»åŠ ä¸€ä¸ªè‡ªå·±ç®¡ç†çš„é…ç½®é¡¹å€¼ sys-clientVersionï¼Œï¼ˆæ‰€æœ‰å±•ç¤ºç›¸å…³å…¨ç”¨è¯¥å€¼ï¼‰ï¼Œä¸Šä¼ App Storeï¼Œæ–°ç‰ˆæœ¬å†™æˆ sys-clientVersion ä¸€æ ·çš„å€¼å³å¯ã€‚

å‚è€ƒï¼š[iOS APPä»æ‰“åŒ…åˆ°å‘å¸ƒappStoreå®Œæ•´æµç¨‹ï¼ˆå«4ä½ç‰ˆæœ¬å·å®ç°ï¼‰](https://www.jianshu.com/p/860fdd8860cc)





2. åœ¨iTunes Connect é‡Œæ–°å»ºäº†é¡¹ç›®ï¼Œå¯¼å…¥iconå›¾ç‰‡æ—¶ï¼Œé‡åˆ°ä»¥ä¸‹é—®é¢˜

<img src="../assets/image-20200928162607268.png" alt="image-20200928162607268" style="zoom:50%;" />





### 2. AFNetworking

**æŠ¥é”™:(415 Domain=com.alamofire.error.serialization.response Code=-1011 "Request failed: unsupported media type (415)")**

è§£å†³ï¼šåœ¨å¯¹è¯·æ±‚æ•°æ®æ ¼å¼å’Œå“åº”**æ•°æ®æ ¼å¼**åˆå§‹åŒ–çš„æ—¶å€™,å°†ä¹‹å‰çš„çˆ¶ç±»ï¼ˆAFHTTPRequestSerializerï¼‰æ¢æˆäº†å®ƒçš„å­ç±»(AFJSONRequestSerializerï¼‰

```objective-c
manager.requestSerializer = [AFJSONRequestSerializer serializer];
manager.responseSerializer = [AFJSONResponseSerializer serializer];
```



### 3. GCD

æˆ‘ä¹‹å‰çš„æ–‡ç« ï¼š

[å¤šçº¿ç¨‹ç¼–ç¨‹çŸ¥è¯†æ•´ç†](./articles/2018-12-02-iOS-å¤šçº¿ç¨‹ç¼–ç¨‹çŸ¥è¯†æ•´ç†.md)

[iOS-å¤šçº¿ç¼–ç¨‹ä¹‹çº¿ç¨‹å®‰å…¨](./articles/2018-12-11-iOS-å¤šçº¿ç¼–ç¨‹ä¹‹çº¿ç¨‹å®‰å…¨.md)

[iOSå¤šçº¿ç¨‹ä¹‹åŒæ­¥å¼‚æ­¥ã€ä¸²è¡Œå¹¶è¡Œ](./articles/2018-12-18-iOSå¤šçº¿ç¨‹ä¹‹åŒæ­¥å¼‚æ­¥ã€ä¸²è¡Œå¹¶è¡Œ.md)

[Runloopä¸çº¿ç¨‹ä¿æ´»](./articles/2018-12-15-iOS-Runloopä¸çº¿ç¨‹ä¿æ´».md)



iOS å¼€å‘ä¸­ï¼Œæˆ‘ä»¬ç»å¸¸ä½¿ç”¨ GCD æ¥å¤„ç†å¹¶å‘ã€‚æˆ‘ä»¬å¹¶ä¸å…³å¿ƒçº¿ç¨‹çš„ç®¡ç†ï¼Œå¼€å¤šå°‘çº¿ç¨‹æ˜¯ç”± GCD å°è£…çš„çº¿ç¨‹æ± å†³å®šçš„ï¼ˆå»ºè®®3~5æ¡ï¼‰ï¼Œçº¿ç¨‹æ± ç”±ç³»ç»Ÿè‡ªåŠ¨æ¥ç»´æŠ¤ã€‚æˆ‘ä»¬é€šå¸¸çš„æ“ä½œæ˜¯å‘**é˜Ÿåˆ—**ä¸­æ·»åŠ **ä»»åŠ¡**ï¼Œé˜Ÿåˆ—è°ƒåº¦å³å¯ï¼

![](../assets/dispatchQueue2018.png)

é—®é¢˜ï¼šå–æ¶ˆæ“ä½œï¼ˆä»»åŠ¡ï¼‰ åœ¨ GCD ä¸­ï¼Œæ˜¯æ²¡åŠæ³•å¯¹æ·»åŠ åˆ° `queue` çš„ `task` è¿›è¡Œ `cancel`æ“ä½œçš„ï¼**ps. è¿™é‡Œçš„å–æ¶ˆåªé’ˆå¯¹å°šæœªæ‰§è¡Œçš„ä»»åŠ¡ï¼Œå¯¹æ­£åœ¨æ‰§è¡Œçš„ä»»åŠ¡ä¸èµ·ä½œç”¨ï¼ï¼ï¼**

æ–¹æ¡ˆ1ï¼š**dispatch_block_cancel**

iOS 8 ä»¥åï¼Œå¯ä»¥è°ƒç”¨ **dispatch_block_cancel** æ¥å–æ¶ˆç”¨ **dispatch_block_create** åˆ›å»ºçš„ **dispatch_block_t**

```objective-c
- (void)gcdBlockCancel{
    dispatch_queue_t queue = dispatch_queue_create("com.gcdtest", DISPATCH_QUEUE_CONCURRENT);
    
    dispatch_block_t block1 = dispatch_block_create(0, ^{
        sleep(5);
        NSLog(@"block1 %@",[NSThread currentThread]);
    });
    
    dispatch_block_t block2 = dispatch_block_create(0, ^{
        NSLog(@"block2 %@",[NSThread currentThread]);
    });
    
    dispatch_block_t block3 = dispatch_block_create(0, ^{
        NSLog(@"block3 %@",[NSThread currentThread]); // è¯¥ä»£ç å—å–æ¶ˆæ‰§è¡Œ
    });
    
    dispatch_async(queue, block1);
    dispatch_async(queue, block2);
    dispatch_block_cancel(block3);
}
```



æ–¹æ¡ˆ2ï¼š**å®šä¹‰å¤–éƒ¨å˜é‡ï¼Œç”¨äºæ ‡è®° block æ˜¯å¦éœ€è¦å–æ¶ˆ**

è¯¥æ–¹æ³•å…¶å®å°±æ˜¯åœ¨å‚è€ƒ **NSOperation** çŠ¶æ€æœºåˆ¶ï¼Œåœ¨æ‰§è¡Œ block å‰å…ˆæ£€æŸ¥æ ‡è®°å˜é‡ `isCancelled == YES `ã€‚

åœ¨ block ä¸­åŠæ—¶çš„æ£€æµ‹æ ‡è®°å˜é‡ï¼Œå½“å‘ç°éœ€è¦å–æ¶ˆæ—¶ï¼Œç»ˆæ­¢åç»­æ“ä½œã€‚

```objective-c
- (void)gcdCancel{
    
    dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);
    
    __block BOOL isCancelled = NO;
    
    dispatch_async(queue, ^{
        NSLog(@"ä»»åŠ¡1 %@",[NSThread currentThread]);
    });
    
    dispatch_async(queue, ^{
        NSLog(@"ä»»åŠ¡2 %@",[NSThread currentThread]);
    });
    
    dispatch_async(queue, ^{
        NSLog(@"ä»»åŠ¡3 %@",[NSThread currentThread]);
        isCancelled = YES;
    });
    
    dispatch_async(queue, ^{
        // æ¨¡æ‹Ÿï¼šçº¿ç¨‹ç­‰å¾…3ç§’ï¼Œç¡®ä¿ä»»åŠ¡3 æ ‡è®°å˜é‡isCancelledï¼YESå®Œæˆ
        sleep(3);
        if(isCancelled){
            NSLog(@"ä»»åŠ¡4å·²è¢«å–æ¶ˆ %@",[NSThread currentThread]);
        }else{
            NSLog(@"ä»»åŠ¡4 %@",[NSThread currentThread]);
        }
    });
}
```



æ—¢ç„¶æåˆ°äº†  NSOperation çš„ **- (void)cancel;** æ–¹æ³•ï¼Œé‚£å°±å±•å¼€è®²ä¸€ä¸‹ã€‚æ²¡æœ‰ä»€ä¹ˆæ¯”å®˜æ–¹æ–‡æ¡£æ›´æ‡‚ğŸ˜ï¼š

> This method does not force your operation code to stop. Instead, it updates the objectâ€™s internal flags to reflect the change in state. If the operation has already finished executing, this method has no effect. Canceling an operation that is currently in an operation queue, but not yet executing, makes it possible to remove the operation from the queue sooner than usual. 
>
> In macOS 10.6 and later, if an operation is in a queue but waiting on unfinished dependent operations, those operations are subsequently ignored. Because it is already cancelled, this behavior allows the operation queue to call the operationâ€™s `start` method sooner and clear the object out of the queue. If you cancel an operation that is not in a queue, this method immediately marks the object as finished. In each case, marking the object as ready or finished results in the generation of the appropriate KVO notifications. 
>
> In versions of macOS prior to 10.6, an operation object remains in the queue until all of its dependencies are removed through the normal processes. Thus, the operation must wait until all of its dependent operations finish executing or are themselves cancelled and have their `start` method called. 
>
> For more information on what you must do in your operation objects to support cancellation, see [Responding to the Cancel Command](doc://com.apple.documentation/documentation/foundation/nsoperation?language=objc#1661262).