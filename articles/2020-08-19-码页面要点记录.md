# 码页面要点记录

### 响应链相关

我之前写过相关文章 [iOS中事件的响应和传递](./articles/2020-5-27-iOS中事件的响应和传递.md) 可以先看看

**1 穿透触发事件**，比如：需要点击选中 view 触发事件。那么就需要**穿透**在选中 view 之上的 view

![image-20200819111707046](../assets/image-20200819111707046.png)



实现：在目标父 view 重写 `- (UIView *)hitTest:(CGPoint)point withEvent:(UIEvent *)event;` 方法

```objective-c
- (UIView *)hitTest:(CGPoint)point withEvent:(UIEvent *)event {
    if (!self.userInteractionEnabled || [self isHidden] || self.alpha <= 0.1) {
        return nil;
    }
    if ([self pointInside: point withEvent: event]) {
        __block UIView *hit = nil;
        [self.subviews enumerateObjectsWithOptions: NSEnumerationReverse usingBlock:^(__kindof UIView * _Nonnull obj, NSUInteger idx, BOOL * _Nonnull stop) {
            // 隐藏view直接跳出本次循环
            if (obj.hidden) {
                return;
            }
          	// 坐标转换
            CGPoint currentPoint = [self convertPoint: point toView: obj];
          	// 递归调用
            hit = [obj hitTest: currentPoint withEvent: event];
            // 透传目标点击事件
            CGPoint aimViewPoint = [obj convertPoint:currentPoint toView:self.container];
            if (CGRectContainsPoint(self.aimView.frame, aimViewPoint)) {
                hit = self.aimView;
            }
            // 命中退出循环
            if (hit) {
                *stop = YES;
            }
            
        }];
        
        if (hit) {
            return hit;
        } else {
            return self;
        }
    } else {
        return nil;
    }
}
```



**2 超出父 view 的 frame，触发事件**。比如：要拖动超出父 view 的 slider 



![image-20200819112257418](../assets/image-20200819112257418.png)



实现：重写 slider 父 view 的  `- (UIView *)hitTest:(CGPoint)point withEvent:(UIEvent *)event;` 方法

```objective-c
- (UIView *)hitTest:(CGPoint)point withEvent:(UIEvent *)event {
  	// slider 在所在view父视图的frame
    CGRect frameInSuper = [self convertRect:self.slider.frame toView: self.superview];
    if ((!self.slider.hidden) && CGRectContainsPoint(frameInSuper, point)) {
        return self.slider.hidden;
    }
    return [super hitTest:point withEvent:event];
}

```



### Gesture 手势相关

遇到的问题是：iOS 13 在给 view 添加了 swipe 手势后，页面上的 slider 滑动**不跟手**。

解决：给 slider 添加了一个无效的 pan 手势

```objective-c
// target nil / action NULL
UIPanGestureRecognizer *panGesture = [[UIPanGestureRecognizer alloc] initWithTarget:nil action:NULL];
panGesture.cancelsTouchesInView = false;
[_slider addGestureRecognizer:panGesture];
```



### 获取 top Window 和 top VC

给 UIViewController 添加分类方法：

```objective-c
/// 获取top window
+ (UIWindow *)xxx_topWindow {
    NSArray *windows = [UIApplication sharedApplication].windows;
    for (UIWindow *window in [windows reverseObjectEnumerator]) {
        if ([window isKindOfClass:NSClassFromString(@"UITextEffectsWindow")]) {
            continue;
        }
        if (!window.isHidden && [window isKindOfClass:[UIWindow class]] && CGRectEqualToRect(window.bounds, [UIScreen mainScreen].bounds))
            return window;
    }
    return [[UIApplication sharedApplication].delegate window];
}
/// 获取 top viewcontroller
+ (UIViewController *)xxx_topViewController {
    UIViewController *topController = [[self xxx_topWindow] rootViewController];
    while (topController.presentedViewController) {
        topController = topController.presentedViewController;

        if ([topController isKindOfClass:[UINavigationController class]]) {
            topController = [(UINavigationController *)topController visibleViewController];
        } else if ([topController isKindOfClass:[UITabBarController class]]) {
            topController = [(UITabBarController *)topController selectedViewController];
        }
    }
    return topController;
}
```



### 调整 progressView 的宽、高以及两端弧度

```objective-c
//这里是设定progressView的模式为默认模式
self.progressView = [[UIProgressView alloc] initWithProgressViewStyle:UIProgressViewStyleDefault];
self.progressView.frame = CGRectMake(16, CGRectGetMaxY(label1.frame) + 15, SCREEN_WIDTH - 32 - image3.size.width - 25, 8);
//设定progressView的显示颜色
self.progressView.progressTintColor=COLOR_THEME;
CGAffineTransform transform = CGAffineTransformMakeScale(1.0f, 2.0f);
//设定宽高
self.progressView.transform = transform;
//设定宽高
self.progressView.trackImage = image4;
self.progressView.contentMode = UIViewContentModeScaleAspectFill;
//设定两端弧度
self.progressView.layer.cornerRadius = 1.0;
self.progressView.layer.masksToBounds = YES;
//设定progressView的现实进度（一般情况下可以从后台获取到这个数字）
[self.progressView setProgress:0.70 animated:YES];
[self.view addSubview:self.progressView];
```

