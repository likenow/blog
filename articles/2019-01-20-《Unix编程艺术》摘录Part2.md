---
title: 《Unix编程艺术》摘录Part2
date: 2019-01-20 14:13:02
tags:
- Unix
categories:
- 操作系统
---

## 前言

[《Unix编程艺术》摘录Part1](https://dnduuhn.com/2019/01/15/%E3%80%8AUnix%E7%BC%96%E7%A8%8B%E8%89%BA%E6%9C%AF%E3%80%8B%E6%91%98%E5%BD%95Part1/) 是1~3章的内容，本文将继续介绍4~7章的内容。继续学习。。。

<!--more-->

## 4. 模块性：保持清晰，保持简洁

一开始，一切都是一大块机器码；最早的过程语言首先引入了用子程序划分代码的概念。后来，发明了服务程序库，在多个程序间共享公用函数。后来，我们发明了独立地址空间和可以相互通讯的进程。今天，我们习以为常的把程序系统分布在通过成千上万公里的网络电缆连接的多台主机上。

用定义清晰的接口把若干简单模块组织起来。

### 4.1 封装和最佳模块大小

封装良好的模块不会过多向外披露自身的细节，不会直接调用其他模块的实现代码，也不会胡乱共享全局数据。

API：一组严密、定义良好的程序调用和数据结构来通信。

​	实现层面

​	设计层面

定义接口-->编写注释-->编写代码

编写注释的过程就阐明了代码必须达到的目的。

软件系统应设计成：有层次分明的嵌套模块组成，而且每个层面上的模块粒度应降至最低。

`200-400` 逻辑行的代码是”最佳点“，可能的缺陷密度达到最小。

逻辑行与物理行之间为两倍的折算率，即最佳无量行数建议 `400-800`

### 4.2 紧凑性和正交性

具有最佳尺寸的模块并不意味着代码由高质量。由于受到同样的人类认知限制，语言和API也会产生 `Hatton U型曲线`

#### 4.2.1 紧凑性：一个设计是否能装进人脑中的特性。

实际上极少有绝对意义上紧凑的软件设计。如果通常只需要一个参考卡（`reference  card`）或备忘单（`cheat sheet`），而不是一本手册，那么可称之为”半紧凑型“

> 《The Magic Number SEVEN, Plus or Minus Two, Some Limits on Our Capacity For Processing Information》
>
> 《神奇的数字 7，加减2：人类信息处理能力的局限性》

有些问题简直太复杂了，一个紧凑的设计不可能有如此跨度。有时，为了其他优势，如纯性能和适应范围等，也有必要牺牲紧凑性。所以，合理对待紧凑型，设计尽量考虑，中绝不轻易抛弃。

#### 4.2.2 正交性：是有助于使复杂设计也能紧凑的最重要特性之一。

在纯粹的正交设计中，任何操作均无副作用，每个动作只改变一件事，不会影响其他。无论你控制的是什么系统，改变每个属性的方法有且只有一个。

显示器就是正交控制的。eg.你可以独立改变亮度而不影响对比度。

`Doug Mcillroy`--只做好一件事

> 《程序员修炼之道》有对正交性精彩的论述

既不产生副作用也不依赖其他代码副作用的的代码，正交性良好。正交性的代码更容易文档化和复用。

重构：改变代码的结构和组织，而不改变其外在行为。

#### 4.2.3 SPOT （Single Point Of Truth）真理的单点性

> Dot't repeat yourself 不要重复自身 -- 《程序员修炼之道》

> 无垃圾，无混淆 No junk，No confusion

#### 4.2.4 紧凑性和强单一中心

试探法—凭经验则得出的解决方案，在概率上可能正确，但不一定总是正确。

#### 4.2.5 分离的价值

### 4.3 软件是多层的

#### 4.3.1 自顶向下和自底向上

自底向上：从具体到抽象

自顶向下：从抽象到具体

​	1. 能够精确预知程序的任务

​	2. 在实现过程中，程序规格不会发生重大变化

​	3. 在底层，有充分自由来选择程序完成任务的方式

通常，一方面自顶向下的应用逻辑表达抽象规范；另一方面以函数或库来收集底层的域原语。这样，当高层设计发生变化时，这些域源语仍然可以重用。

#### 4.3.2 胶合层

当自顶向下和自底向上发生冲突时，顶层的应用逻辑和底层的域原语集，必须用胶合逻辑层来进行阻抗匹配。（`impedance match`）

胶合层必须薄薄一层，用来将东西粘合在一起，但不应该用来隐藏各层的裂痕和不平整。

如果有许多代码既不属于策略又不属于机制，就很有可能除了增加系统的整体复杂度之外，没有任何其他用处。

#### 4.3.3 被视为薄胶合层的C语言

> 《计算机体系：概念和演化》

二进制表示

平面地址空间

内存和运行期存储（寄存器）的区分

通用寄存器

定长字节的地址解析

双地址指令

高位字节优先以及大小一致为4位或6位（已经淘汰）的数据类型

> ”完美之道，不再无可增加，而在无可删减“

### 4.4 程序库

共享库，`window` 上称为动态链接库

插件可以用来完成多种专用转换

### 4.5 Unix 和 面向对象语言

薄胶合浅分层

如何将分离法的优点（将问题从原始的场景中简化、归纳）同代码和设计的薄胶合、浅平透层次结构的优点相结合。

### 4.6 模块式编码

- 有多少全局变量？
- 单个模块的大小是否符合Hatton的”最佳范围“？
- 模块内的单个函数是不是太大了？
- 代码是不是有内部 API
- API 的入口点是不是超过7个？有没有哪个类有7个以上的方法？数据结构的成员是不是超过7个？
- 整个项目中每个模块的入口点数量如何分布？是不是均匀？模块复杂度往往与入口点数量的平方成正比

## 5. 文本化：好协议产生好实践

数据格式和应用协议文本化的重要性。

设计将应用数据存储在永久存储器中的文件格式，和在协作程序中（可能会通过网络）传递数据和命令的应用协议。这两种设计的共通之处在于：两者都与内存数据结构的序列化有关。

为了便于数据的传输和存储，像链表这样的数据结构，其可变历的准空间部署需要平整化或序列化成字节流表达，以便日后能从这个表达中恢复数据结构。序列化（保存）操作有事也称为**列集**，其反向操作（载入）称为**散集**

### 5.1 文本化的重要性

使用二进制的唯一正当理由：如果要处理大批量的数据集，因而确实关注能否在介质上获得最大位密度，或是非常关心将数据转化为芯片核心结构所必须的时间或指令开销。

#### 5.1.1 Unix 口令文件格式

#### 5.1.2 .newsrc 格式

#### 5.1.3 PNG 图形文件格式

### 5.2 数据文件源格式

数据文件元格式是一套句法和词法约定，这套约定或者已经正式标准化，或者已经通过实践得到了充分的确定，已有标准服务库来处理列集和散集操作。

#### 5.2.1 DSV 格式

`Delimiter-Separated Values`（分隔符分隔值）

`CSV` （逗号分隔值），`Microsoft` 版 `CSV` 是一个如何设计文本文件格式的反面教材。

#### 5.2.2 RFC 822 格式

源自互联网电子邮件信息采用的文本格式；

`RFC 2822`

#### 5.2.3 Cookie-Jar 格式

是 `fortune(1) `程序为随机引用数据库而使用的一种格式。适用记录只是一堆非结构化文本的情况。

#### 5.2.4 Record-Jar 格式

`cookie-jar` 记录分隔符和`RFC 822 `记录源格式结合的非常好，产生一种`Record-Jar` 格式。

适合于那些类似 `DSV `文件、但又有可变字段数目而且可能伴随无结构文本的字段属性关系集合。

#### 5.2.5 XML

尖括号`<>`的标签和 `&`记号引导字面值序列。

适合那些` RFC 822` 元格式不太好处理、有复杂递归或嵌套数据结构的格式。

`PYX` 格式，面向行的 `XML` 转换。

> keep it simple, stupid!

`XML` 不能与 Unix 常规工具很好的配合使用。需要` XML` 解析器

#### 5.2.6 Windows INI 格式

如果数据围绕指定的记录或部分能够分成`”名称-属性对“`两层组织结构，`.INI `格式非常适用。

#### 5.2.7 Unix 文本文件格式的约定

- 如果可能，以新行符结束的每一行只存一个记录。
  - 习惯上忽略行尾的空白
- 如果可能，每行不超过80个字符
- 使用 `#`引入注释
- 支持反斜杠约定
  - `\n` 表示新行
  - `\r` 表示回车
  - `\t` 表示制表符
  - `\b` 表示退格
  - `\f` 表示走纸
  - `\e` 表示**ASCII escape(27)**
  - `\nnn`或`\onnn`或`\0nnn` 表示八进制值为nnn的字符
  - `\xnn` 表示十六进值值为nn的字符
  - `\dnnn` 表示十进制值为nnn的字符
  - `\unnn` 表示十六进制的Unicode字面值
  - `\\`表示反斜杠
- 在每一条记录的格式中，使用冒号或任何连续的空白作为字段分隔符。
- 不要过分区别 `tab`和`whitespace`
  - 允许使用连续的 `tab`和`whitespace`作为分隔符非常有效
- 优先选用十六进制而不是八进制 
- 对于复杂的记录，使用”节（stanza）“格式：一个记录若有多行，就是用`%%\n`或`%\n`作为记录分隔符
- 在节格式中，要么每行一个记录字段，要么将记录格式和RFC 822 电子邮件头类似，用冒号终止的字段名关键字作为引导字段。
- 在节格式中，支持连续航。
- 要么包含一个版本号，要么将格式设计成相互独立的自描述字节块。
  - 无需立即破坏旧代码就可以增加新的块类型
- 注意浮点数取整问题。
- 不要仅对文件的一部分进行压缩或者二进制编码。

#### 5.2.8 文件压缩的利弊

压缩工具可以扫描所有数据，然后找到信息中的所有重复部分进行压缩。

将表现形式的设计和具体压缩的方法分离。

压缩，在某种程度上损坏了透明性。

方案的最优解取决于：对存储经济型、可显性或让浏览工具编写起来尽可能简单等问题的权衡考虑。

### 5.3 应用协议设计

段对端（`end-to-end`）设计守则。

> 《系统设计中的端对端论》(End-to-End Arguments in System Design)

#### 5.3.1 SMTP 一个简单的套接字协议（简单邮件传送协议）

#### 5.3.2 POP3 邮局协议（Post Office Protocol）

`SMTP` 是邮件发送者启动事务处理的”推“协议，而 `POP3 `是邮件接收者启动事务处理的”拉“协议。

不连续访问互联网的用户可以让他们的邮件存放在一个邮箱机器上，然后使用`POP3`连接将邮件通过网线接收到自己的电脑上。

`POP3` 与 `SMTP` 最明显的不同是：

- `POP3` 使用状态标记，`SMTP `使用`3位`数的状态码
- 请求的语义不同

#### 5.3.3 IMAP 互联网消息访问协议

`IMAP` 对有效载荷部分的分割方法略有不同，它不是用一个点号来结束，而是将有效载荷的长度直接放在有效载荷之前发送。这稍稍增加了服务器的负担（消息必须提前完成组合，无法在初始化后流转），但使客户端工作更容易了—客户端可以提前知道，需要分配多少存储空间作为整个处理消息的缓冲区。

每个响应都标上了由请求提供的序列标签。这个特性使` IMAP `命令无需等待响应就可以流向服务器端；然后客户端的状态机就能够在回来时直接解析响应和有效数据载荷，这样可以减少等待时间。

### 5.4 应用协议元格式

#### 5.4.1 经典的互联网应用元协议

> Marshall Rose 的 RFC 3117 《论应用协议的设计》（On the Design of Application Protocols）

- 文本格式
- 单行请求和响应，但有效数据载荷可以多行
  - 有效数据载荷要么是8位组数据作为前导，要么以`\r\n`作为结束符
  - 有效数据载荷在字节上已被补齐
- 所有以句点`.`开始的行前面需要另加一个句点，接收方既负责识别结束符有负责去除补齐字节
- 应答行由状态码和后接人可识别的消息构成

#### 5.4.2 作为通用应用协议的 HTTP

自从万维网在1993年左右吸引到足量用户以来，应用协议的设计者越来越倾向于在 HTTP 上构建专属协议，并使用网页服务器作为通用服务平台。

HTTP 请求采用类似` RFC-822/MIME `格式的消息：通常，消息头包含识别和认证信息，第一行是对通用资源指示符（`URI`）指定的某个资源的方法调用。

`URI `最重要的形式是 `URL`（`Uniform Resource Locator`），即统一资源定位符。

`URL `通过服务类型、主机名称和在主机上的位置对资源进行识别。

HTTP 响应只是一种`RFC-822/MIME`消息，可以包含由客户端解释的任意内容。

> RFC 3205 《论使用 HTTP作为底层》（On the Use of HTTP As a Substrate）

##### 5.4.2.1 实例分析： CDDB/freedb.org 数据库

基于 TCP/IP 的自定义应用协议的查询服务需要：

- 分配一个新的 TCP/IP 端口号
- 从成千上万的防火墙上争取到通路

而，如果服务基于 HTTP作为简单的 `CGI`（`Common Gateway Interface`）查询毫不费力。

##### 5.4.2.2 实例分析：互联网打印协议（Internet Printing Protocol）

`IPP` 使用 HTTP 1.1 作为传输协议

> 《互联网打印协议模型和结构基本原理》(Rationale fot the Structure of the Model and Protocol for the Internet Printing Protocol)

`RFC 2568` 的 4.2 节解释了做出这种选择的理由

#### 5.4.3 BEEP：块可扩展交换协议

BEEP 的特点：

- 既支持客户端/服务器模式
- 又支持对等网模式（`peer-to-peer`）

#### 5.4.4 XML-RPC SOAP 和 Jabber

`SOAP`（`Simple Object Access Protocol`，简单对象访问协议）用于远程过程调用

`Jabber` 用于即时消息和在线状态报告

## 6 透明性：来点儿光

#### 6.1.1 audacity

#### 6.1.2 fetchmail 的 -v

#### 6.1.3 GCC

#### 6.1.4 kmail

#### 6.1.5 SNG（Scriptable Network Graphics）

#### 6.1.6 Terminfo 数据库

#### 6.1.7 freeciv 数据文件

服务器会忽略它不知道如何使用的属性名。这使得可能在不中断启动解析的前提下对服务器还没有使用的属性进行声明。这意味着**游戏数据（策略）的开发和服务引擎（机制）的开发可以分离出来**。

另一方面，这也意味着启动解析不会理会属性名简单的拼写错误。这种不声不响的”不作为“似乎违反了补救原则。

要解决这个冲突，应注意：使用登记表数据是服务器的工作，但是仔细检查数据的任务可以移交给另一个程序，每次修改登记表时，由编辑人员运行这个程序。

### 6.2 为透明性和可显性而设计

#### 6.2.1 透明性之禅

要追求代码的透明性，最有效的方法就是：不要在具体操作的代码上叠放太多的抽象层。

#### 6.2.2 为透明性和可显性而编码

#### 6.2.3 透明性和避免过度保护

隐藏细节和无法访问细节有着重要区别

不能展示其行为的程序使故障检测困难得多。

调试和探测开关的存在与否视为良好程序的标志。

#### 6.2.4 透明性和可编辑的表现形式

把表现形式的损失降到最小

能够在可编辑的文本格式和二进制格式之间来回进行无损转换。-- **文本化器**

如果二进制对象是动态生成的，或者非常大，那么用文本化器转化所有状态可能不实际或者根本不可能。在这种情况下，对应的任务是编写一个浏览器。

#### 6.2.5 透明性、故障诊断和故障恢复

透明的系统更容易实施恢复措施，而且，经常是，首先更能抵抗bug的破坏。

### 6.3 为可维护性而设计

活代码：周围存在一个非常活跃的开发社团。

睡代码：经常因为对作者而言，维护代码的痛苦超过了代码本身的效用。

死代码：睡得太久，重新实现一段等价代码更容易。

## 7 多道程序设计：分离进程为独立的功能

Unix 提倡把程序分解成更简单的子进程，并专注考虑这些子进程间的接口。

Unix 强调用定义良好的进程间通信或共享文件来联通小型进程。

- 降低进程生成开销
- 提供方法简化进程间通信
  - shell 执行模块
  - I/O 重定向
  - 管道
  - 消息传递
  - 套接字
- 提倡使用能由管道和套接字传递的简单、透明的文本数据格式

**协议逻辑**

### 7.1 从性能调整中分离复杂度控制

线程提高了全局复杂度

### 7.2 Unix IPC 方法的分类

#### 7.2.1 把任务转给专门程序

##### 7.2.1.1 实例分析：mutt 邮件用户代理

#### 7.2.2 管道、重定向和过滤器

Malcolm Douglas McIlroy 发明的管道结构

- 标准输入
- 标准输出

通常，这些数据流分别和用户的键盘和显示器相连。但是 Unix shell 普遍支持重定向操作，可以把这些标准输入输出流连接到文件。

管道的主要缺点是：单向性。管道线的成员除了终止外（这种情况，前一阶段的程序会在下一个写操作时得到 `SIGPIPE` 信号）不可能回传控制信息。因此，传输数据的协议简化为接收端的输入格式。

##### 7.2.2.1 实例分析：为分页程序建立管道

`ps|more` 

`more` ->`less`

##### 7.2.2.2 实例分析：制作单词表

通过管道相连的程序来协作

##### 7.2.2.3 实例分析：pic2graph

管道和过滤器怎样使程序适应非预期的用法。

##### 7.2.2.4 实例分析：bc(1) 和 dc(1)

尽管 `bc(1)`目前的GNU实现版本不依赖其他程序，其经典版本却通过管道把命令传递给 `dc(1)`。在这种分工中，`bc(1)`完成变量代入和函数展示，并将中缀表示法转换为逆波兰表示法—但实际上本身并不完成计算，相反，把输入表达式转换成` RPN `形式传递给 `dc(1)`，由`dc(1)`来完成计算。

##### 7.2.2.5 反例分析：为什么 fetchmail 不是管线

管线是单向的

#### 7.2.3 包装器

和 `shellout `相对的是包装器。

包装器之所以存在，常常源于要指定参数来修改被调用程序的行为。

##### 7.2.3.1 实例分析：备份脚本

`tar -czvf /dev/st0 "$@" `

#### 7.2.4 安全性包装器与 Bernstein 链

安全性包装器可调用守门程序检查某类凭证，然后根据返回的状态值有条件的执行另一个程序。

`Bernstein 链`是一个专用化的安全性包装器技法。

#### 7.2.5 从进程

在编写主/从进程对时，一个好的方法是，让主进程支持命令行开关或环境变量来允许调用者设置自己的从进程命令。

##### 7.2.5.1 实例分析：scp 和 ssh

`scp(1)`安全拷贝命令把`ssh(1)`作为从进程调用，从`ssh`的标准输出中截取足够的信息，然后把报告重新组织成为 ASII 动画形式的进度条。

#### 7.2.6 对等进程间通讯

##### 7.2.6.1 临时文件

把临时文件作为协作程序之间的通信中转站使用，是最古老的IPC技法。虽然存在一些缺点，但临时文件在shell脚本以及一些一次性程序中仍然非常有用。

1. 把临时文件作为IPC技法使用最明显的问题是:

- 如果进程在临时文件可被删除前中断，则往往会遗留垃圾数据。

2. 另一个隐蔽风险是：
   - 如果程序的多个实例都使用同一个名字作为临时文件名，则会产生冲突。

这就是为什么shell脚本的惯例是在临时文件名中包含`$$`符号的原因；这个 shell 变量将被展开为载入 shell 的进程 ID，从而有效保证了文件名的唯一性。（Perl 也支持同样的技巧）

3. 如果攻击程序知道临时文件将要写入的位置，就可以覆盖掉那个文件，很可能读取生产者进程的数据，或者通过在文件中插入修改或假造的数据哄骗消费者进程。

撇开这些缺点，临时文件仍然还有一席之地。因为他们很同意创建，很灵活，与那些复杂的方法相比，没那么容易产生死锁和竞争。

子进程的调用约定可能要求子进程必须得到一个文件来操作。

##### 7.2.6.2 信号

Unix 信号是一种软中断形式：每个信号都对接收进程产生默认作用（通常是杀掉它）。进程可以声明信号处理程序，让信号处理程序覆盖信号的默认行为；处理程序是一个与接受信号异步执行的函数。

信号被设计进Unix，最初是作为操作系统就某些错误或关键事件通知程序的一种机制，并不是作为 IPC 功能设计进来的。

##### 7.2.6.3 系统守护程序和常规信号

##### 7.2.6.4 实例分析：fetchmail 的信号使用

`fetchmail` 实用程序通常被配置成在后台运行的守护程序，无需用户干预就能定期从运行控制文件定义的所有远程站点收集邮件，并传送给`端口25`的本地`SMTP`监听程序。

##### 7.2.6.5 套接字

套接字作为一种封装网络数据访问的方法。通过套接字通信的两个程序通常都存在双向字节流。

字节流既是按序的，又是可靠地。

在创建套接字的时候，可以指定协议簇来告诉网络层如何解释套接字的名称。

人们通常认为套接字和互联网有关，是一种在不同主机上运行的程序之间传递数据的方法，这是 `AF_INET` 套接字簇。在这个套接字簇中，地址被解释为主机地址和服务编号对。然而，`AF_UNIX`（也称之为 `AF_LOCAL`）协议簇支持同样的套接字抽象，作为在同一台机器上两个进程之间的通信方式。

###### 7.2.6.5.1 实例分析：PostgreSQL

当用户运行 `PostgreSQL` 时，该客户端启动一个和`postmanager`的**会话**并与之进行 SQL 事务处理。服务器程序可以一次处理好几个客户端回话，并且对这些请求排队，所以他们不会互相干扰。

###### 7.2.6.5.2 实例分析：Freeciv

客户端和服务器的划分

`Freeciv `游戏的运行状态由服务器进程，即游戏引擎来维护。玩家运行 GUI 客户端，通过包协议和服务器交换信息和命令。所有的游戏逻辑都在服务器端处理，GUI的细节在客户端处理，不同的客户端支持不同的界面风格。

这是多人在线游戏非常典型的一种结构。包协议使用`TCP/IP`进行传输，因此服务器可以处理运行在不同互联网主机上的客户端。其它那些更像实时模拟(特别是仿真视角射击游戏)的游戏会用原始的互联网数据报协议` UDP` ，并且牺牲了包发送的不确定性来降低延迟。在这种游戏中，用户通常连续的发送控制动作，所以零星的信号丢失是可以忍受的，按时延迟确实致命的。

##### 7.2.6.6 共享内存

共享内存要求生产者和消费者必须在同一硬件上。

如果通信进程能够访问同一个物理内存，则共享内存将是他么之间最快的信息传递方法。

共享内存可能以各种 API 的面貌呈现，但是在现代Unix中，共享内存的实现通常依靠使用` mmap(2)`，把文件映射成可以供多个进程共享的内存。`POSIX` 定义了具有 API 的 `shm_open(3) `功能，支持把文件作为共享内存使用，这通常是对操作系统的提示，告诉他无需把伪文件数据刷到磁盘上。

### 7.3 要避免的问题和方法

#### 7.3.1 废弃的Unix IPC 方法

> 《Unix 网络编程》（Unix Network Programming）

##### 7.3.1.1 System V IPC

基于共享内存的消息传递机制

##### 7.3.1.2 Streams

`Streams Networking `网络流

特性：把协议转换模块推到内核处理线中，这样用户进程通过全双工通道”看到“的设备实际上被过滤掉了。

Linux 和其他开源 Unix 实际上已经抛弃了` STREAMS`。

#### 7.3.2 远程过程调用

> 《对远程过程调用范式的批评》（Critique of the Remote Procedure Call Paradigm[Tanenaum-Van Renesse ]）

`RPC `接口往往产生更糟糕的延迟问题：

- 无法准确预估出一个指定调用会涉及多少数据的列集和散集
- `RPC` 模型往往鼓励程序员把网络交易视为无成本行为

#### 7.3.3 线程--恐吓或威胁

从复杂度控制的角度来看，相对拥有独立地址空间的轻量级进程，线程是个糟糕的替代。线程时那些进程生成昂贵、`IPC` 功能薄弱的操作系统所特有的概念。

从定义上看，尽管进程的子线程通常具有独立的局部变量栈，他们却共享统一全局内存。在这个共享地址空间管理竞争和临界区的任务非常困难，而且成为增加整体复杂度和滋生`bug`的温床。可以这样去做，但是随着锁定机制复杂度的增加，意外交互作用所造成的竞争和死锁机会也相应增加。

线程成为滋生`bug`温床源于他们太容易知道过多彼此的内部状态。与有着独立地址空间、必须通过明确IPC进行通信的进程不同，线程没有自动封装。这样，基于线程的程序不仅产生普通的竞争问题，而且产生了新一类`bug`：**时序依赖**，要重现这些问题都极其困难，遑论修复。

线程编程开始越来越像是对共享内存的有约束应用了。

> 《为什么线程是个馊主意》（Why Threads are a Bad Idea）

### 7.4 在设计层次上的进程划分

第一个要注意的是：临时文件、交互性更强的主/从进程关系、套接字、`RPC` 和其他一些双向` RPC `方法在某种程度上是等价的--他们都只不过是程序在生命期呢交换数据的方法。

所以评估他们引起的程序复杂度开销，以及给设计造成的不透明度。



## 参考文献

- 《The Art of UNIX Programming》（《Unix 编程艺术》）[美]Eric S. Raymond（埃瑞克.S.理曼德）著 姜宏 何源 蔡晓骏