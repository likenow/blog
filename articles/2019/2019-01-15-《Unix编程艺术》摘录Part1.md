---
title: 《Unix编程艺术》摘录Part1
date: 2019-01-15 21:14:22
tags:
- Unix
categories:
- 操作系统
---



## 前言

工作以后，我感觉自己已经走向了”实用主义“和”拿来主义“，即当下工作上用什么我就学什么而且要偏实战，现有的框架和库广受好评的看看文档拿来即用。但是渐渐地发现：

- 新的技术层出不穷根本学不完；
- 优秀的框架一个接一个却没有那个能和我沾边；
- 感觉自己什么都会点儿，但又说不清道不明；

人是活的，不能把路给走死了。所以，学习要学习根本的、基础的而不是飘在表面，水过地皮湿。我开始看以前不怎么重视的书和知识，弥补自己的知识体系上的缺陷，补自己落下的。

本文，就是我读《Unix编程艺术》第一部分，的一些摘录。就这样翻看了一遍，越发觉得自己十多么无知。。。

<!--more-->

## 1. Unix 哲学

### 原则

1. 模块原则：使用简洁的接口拼合简单的部件
2. 清晰原则：清晰胜于机巧
   1. 不仅仅是代码注释，在选择算法和实现时就应该考虑到将来的可扩展性
3. 组合原则：设计时考虑拼接组合
4. 分离原则：策略同机制分离，接口同引擎分离
   1. 前端实现策略，后端实现机制
   2. 避免表象相似而实际却略有不同
5. 简介原则：设计要简洁，复杂度能低则低
   1. 简洁是UNIX程序的核心风格
6. 吝啬原则：除非没有别的办法，否则不要编写庞大的程序
7. 透明性原则：设计要可见，以便审查和调试（透明性和显见性）
8. 健壮原则：健壮源于透明和简洁
   1. 越简洁，越透明，也就越健壮
9. 表示原则：把知识叠入数据以求逻辑质朴而健壮
10. 通俗原则：接口设计避免标新立异
11. 缄默原则：如果一个程序没什么好说的，就保持沉默
12. 补救原则：出现异常，立即退出，并给出足够多的错误日志
    1. 宽容的收，谨慎地发。宽收严发
    2. 要宽容的应该是规范，而不应该是他们的解释器
13. 经济原则：宁花机器一分，不花程序员一秒
14. 生成原则：避免手工hack，尽量编写程序去生成程序
    1. 用程序生成代码，几乎总是比手写代码廉价并且更值得信赖
15. 优化原则：雕琢之前先要有原型，跑之前先学会走
    1. 先制作原型，再精雕细琢。优化之前，先确保能用。
    2. 先求运行，再求正确，最后求块！
16. 多样原则：绝不相信”不二法门“的断言
17. 扩展原则：设计着眼未来，未来总比预想来的快
    1. 过早优化是万恶之源《计算机程序设计艺术》
    2. 稍微增加一点让数据部署具有自描述性的开销，就可以在无需破坏整体的情况下进行扩展。你的付出也就得到了成千的回报。

### 应用Unix哲学

- 只要可行，一切都应该做成与来源和目标无关的过滤器
- 数据流应尽可能文本化（这样可以使用标准工具来查看和过滤）
- 数据库部署和应用协议应尽可能文本化（让人可以阅读和编辑）
- 复杂的前端（用户界面）和后端 应该泾渭分明
- 如果可能，用C编写前，先用解释性语言搭建原型
- 当且仅当，使用一门语言会提高程序复杂度时，混用语言编程才会比单一语言编程来的好
- 宽收严发（对接收的东西要包容，对输出的东西要严格）
- 过滤时，不需要丢弃的信息绝不丢
- 小就是美。在确保完成任务的基础上，程序功能尽可能少。

- 善用工具，尽可能让一切自动化。



## 2. Unix 历史

> Those who cannot remember the past are condemned to repeat it. -- George Santayana
>
> 忘记过去的人，注定要重蹈覆辙

Unix 与 1969 年诞生于贝尔实验室。

UNIX 传统、黑客文化、开源运动

> 远方的人通常比与身边稍有来往的同事更容易合作和建立友谊

**自由软件（free software）**

开源、别和低价而灵活的方案较劲

以上，仅仅是简单摘录几个关键词。有兴趣的同学，应该继续看看书。



## 3. Unix 哲学同其他哲学的比较

- 3.1.1 操作系统的统一性理念
- 3.1.2 多任务能力
  - 多进程并发的能力
  - 协作式多任务
  - 抢先式多任务
- 3.1.3 协作进程
  - 低价的进程生成
  - 简便测进程间通讯（IPC,Internet Process Connection）
  - UNIX 中，一组程序设计时不仅要尽量考虑相互协作，而且要考虑和未知程序的协作。

- 3.1.4 内部边界
  - 程序员最清楚一切
    - Unix 并不阻止也不会让你确认你对自己的数据进行危险操作
    - Unix 小心避免你踩在别人的数据上（Unix 提倡设立多个账户）
  - 三层内部边界：
    - 内存管理，用硬件自身的内存管理单元（MMU,memory management unit）来保证各自的进程不会侵入到其他进程的内存地址空间
    - 多用户设置权限组
    - 把涉及关键安全性的功能限制在尽可能小的可信代码上

- 3.1.5 文件属性和记录结构
  - Unix 都没有
- 3.1.6 二进制文件格式，可能带来的后果：
  - 即使支持命令行接口、脚本和管道，也几乎无法形成过滤器
  - 数据文件只有通过专用工具才能访问。开发者的思维会议工具而非数据为中心，这样不同版本的文件格式很难兼容
- 3.1.7 首选用户界面风格
  - 命令行界面（CLI），如果CLI功能很弱或者根本不存在
    - 程序设计不会考虑以未预料到的方式相互协作。输出不能用作输入
    - 远程系统管理更难于实现，更难以使用，更强调网络
    - 即便简单的非交互程序也将招致GUI开销或复杂的脚本接口
    - 服务器、守护程序和后台进程几乎无法写出，至少很难以优雅的方式写出
  - 图形用户界面（GUI）
- 3.1.8 目标受众
  - 客户端与服务器之分
  - 客户端可以理解为：轻量，只支持单个用户，能够在小型机器上运行，随需开关机器，没有抢先式多任务处理，为低延迟做了优化，大量资源都用在花俏的用户界面上。
  - 服务器可以理解为：重量，能够连续运行，为吞吐量优化，完全抢占式多任务处理以处理多重会话。
- 3.1.9 开发的门槛
  - 开发工具的金钱成本
  - 成为一个熟练开发者的时间成本



> 为了把业务开发者非法化而设立的各种认证计划

> Linux 开发者：不能为在高端硬件上获得最大收益，而在低端机器上增加复杂度和开销



3.3 与Unix 对比，那些消亡的操作系统最大的通病是：

- 不可移植
- 不具备良好的网络支持能力



## 参考文献

- 《The Art of UNIX Programming》（《Unix 编程艺术》）[美]Eric S. Raymond（埃瑞克.S.理曼德）著 姜宏 何源 蔡晓骏











