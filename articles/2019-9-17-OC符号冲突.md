# ç¬¦å·å†²çª

## å‰è¨€

æœ€è¿‘çœ‹å®Œäº†**ã€Šç¨‹åºå‘˜çš„è‡ªæˆ‘ä¿®å…» é“¾æŽ¥ã€è£…è½½ä¸Žåº“ã€‹**  ä¿žç”²å­ çŸ³å‡¡ æ½˜çˆ±æ°‘ è‘—

å…¶ä¸­å¯¹ï¼Œç¬¬ä¸‰ç«  é“¾æŽ¥çš„æŽ¥å£â€”â€”ç¬¦å· éƒ¨åˆ†æ‘˜å½•éƒ¨åˆ†æ¦‚å¿µå¦‚ä¸‹ï¼š

> åœ¨é“¾æŽ¥ä¸­ï¼Œæˆ‘ä»¬å°†å‡½æ•°å’Œå˜é‡ç»Ÿç§°ä¸ºç¬¦å·ï¼Œå‡½æ•°åæˆ–è€…å˜é‡åå°±æ˜¯ç¬¦å·å
>
> ç¬¦å·è¡¨ï¼šè®°å½•äº†ç›®æ ‡æ–‡ä»¶ä¸­æ‰€æœ‰ç”¨åˆ°çš„ç¬¦å·
>
> å¼ºç¬¦å·ï¼šç¼–è¯‘å™¨é»˜è®¤ï¼Œå‡½æ•°å’Œåˆå§‹åŒ–äº†çš„å…¨å±€å˜é‡ä¸ºå¼ºç¬¦å·
>
> å¼±ç¬¦å·ï¼šæœªåˆå§‹åŒ–çš„å…¨å±€å˜é‡ä¸ºå¼±ç¬¦å·
>
> å¼ºç¬¦å·å’Œå¼±ç¬¦å·éƒ½æ˜¯é’ˆå¯¹å®šä¹‰è€Œè¨€ï¼Œä¸æ˜¯é’ˆå¯¹ç¬¦å·çš„å¼•ç”¨ã€‚
>
> å¼ºå¼•ç”¨ï¼šå¯¹å¤–éƒ¨ç›®æ ‡æ–‡ä»¶çš„ç¬¦å·å¼•ç”¨åœ¨ç›®æ ‡æ–‡ä»¶è¢«æœ€ç»ˆé“¾æŽ¥æˆå¯æ‰§è¡Œæ–‡ä»¶æ—¶ï¼Œä»–å¿…é¡»è¦ç¬¦å·å†³è®®ï¼Œå¦‚æžœæ²¡æœ‰æ‰¾åˆ°è¯¥ç¬¦å·çš„å®šä¹‰ï¼Œé“¾æŽ¥å™¨å°±ä¼šæŠ¥ç¬¦å·ä½å®šä¹‰é”™è¯¯ï¼Œè¿™ç§è¢«ç§°ä¸ºå¼ºå¼•ç”¨ã€‚
>
> å¼±å¼•ç”¨ï¼šé“¾æŽ¥å™¨åœ¨å¤„ç†å¼±å¼•ç”¨æ—¶ï¼Œå¦‚æžœè¯¥ç¬¦å·æœ‰å®šä¹‰ï¼Œåˆ™é“¾æŽ¥å™¨å°†è¯¥ç¬¦å·çš„å¼•ç”¨å†³è®®ï¼›å¦‚æžœç¬¦å·æ²¡æœ‰å®šä¹‰ï¼Œé“¾æŽ¥å™¨å¯¹è¯¥å¼•ç”¨ä¸æŠ¥é”™ã€‚

æ¦‚å¿µå…ˆè¯´è¿™ä¹ˆå¤šã€‚æˆ‘ä»¬çŸ¥é“ OC ä¸åƒ C++ æœ‰ Namespace ï¼ˆåç§°ç©ºé—´ï¼‰æ¥å¤„ç†å¤šæ¨¡å—çš„ç¬¦å·å†²çªã€‚

> Objective-C is built directly on top of the C language. One consequence of this is that Objective-C and C share a type system, requiring that identifiers are globally unique.



Xcode ä¸­å‡ºçŽ°äº†ç¬¦å·å†²çªå°±ä¼šæŠ› `Duplicate Symbol` è¿™ä¸ªé”™ã€‚



### é‡åˆ°äº†è¿™ä¸ªé—®é¢˜æ€Žä¹ˆè§£å†³å‘¢ï¼Ÿ**OC æ ¹æœ¬ä¸Šä¾é åŠ å‰ç¼€æ¥ä¿æŒç¬¦å·çš„å…¨å±€å”¯ä¸€**

æžšä¸¾å‡ ç§æƒ…å†µï¼š

1. å¦‚æžœå¯ä»¥çš„è¯å½“ç„¶æ˜¯åŠ ä¸Šå‰ç¼€ï¼Œä¿æŒå”¯ä¸€ã€‚
2. å¦‚æžœé™æ€åº“ä¸èƒ½åŠ¨ï¼Œå¯ä»¥é‡å‘½åæˆ–è€…ä¿®æ”¹å·¥ç¨‹é‡Œçš„ä»£ç é€»è¾‘ã€‚
3. å¦‚æžœå·¥ç¨‹ä¸èƒ½åŠ¨ï¼Œå¯ä»¥é‡å‘½åæˆ–è€…ä¿®æ”¹é™æ€åº“é‡Œçš„ä»£ç é€»è¾‘ã€‚

å®žé™…å¼€å‘ä¸­å›´ç»•ä¸Šè¿°æœ‰ä¸¤ç§å®žæ–½æ–¹æ¡ˆï¼š

#### æ–¹æ¡ˆä¸€ï¼š

ç½‘ä¸Š[What is the best way to solve an Objective-C namespace collision?](https://stackoverflow.com/questions/178434/what-is-the-best-way-to-solve-an-objective-c-namespace-collision)çœ‹åˆ°æœ‰äººä½¿ç”¨ `COM_WHATEVER_ClassName` Objective-Cç¼–è¯‘å™¨æŒ‡ä»¤

> Prefixing your classes with a unique prefix is fundamentally the only option but there are several ways to make this less onerous and ugly. There is a long discussion of options [here](http://www.cocoadev.com/index.pl?AlternativesToPrefixing). My favorite is the `@compatibility_alias` Objective-C compiler directive (described [here](http://developer.apple.com/library/mac/#documentation/DeveloperTools/gcc-4.0.1/gcc/compatibility_005falias.html)). You can use `@compatibility_alias` to "rename" a class, allowing you to name your class using FQDN or some such prefix:
>
> ```c
> @interface COM_WHATEVER_ClassName : NSObject
> @end
> 
> @compatibility_alias ClassName COM_WHATEVER_ClassName
> // now ClassName is an alias for COM_WHATEVER_ClassName
> 
> @implementation ClassName //OK
> //blah
> @end
> 
> ClassName *myClass; //OK
> ```
>
> As part of a complete strategy, you could prefix all your classes with a unique prefix such as the FQDN and then create a header with all the `@compatibility_alias` (I would imagine you could auto-generate said header).
>
> The downside of prefixing like this is that you have to enter the true class name (e.g. `COM_WHATEVER_ClassName` above) in anything that needs the class name from a string besides the compiler. Notably, `@compatibility_alias` is a compiler directive, not a runtime function so `NSClassFromString(ClassName)` will fail (return `nil`)--you'll have to use `NSClassFromString(COM_WHATERVER_ClassName)`. You can use `ibtool` via build phase to modify class names in an Interface Builder nib/xib so that you don't have to write the full COM_WHATEVER_... in Interface Builder.
>
> Final caveat: because this is a compiler directive (and an obscure one at that), it may not be portable across compilers. In particular, I don't know if it works with the Clang frontend from the LLVM project, though it should work with LLVM-GCC (LLVM using the GCC frontend).

```
å¯ä»¥ä½¿ç”¨ @compatibility_alias é‡å‘½å ä¸€ä¸ªç±»ï¼Œå…è®¸ä½¿ç”¨ FQDN æˆ–æŸäº›æ­¤ç±»å‰ç¼€å‘½åçš„ç±»ã€‚

---
@interface COM_WHATEVER_ClassName : NSObject
@end

@compatibility_alias ClassName COM_WHATEVER_ClassName
// now ClassName is an alias for COM_WHATEVER_ClassName

@implementation ClassName //OK
//blah
@end

ClassName *myClass; //OK
---

ä½œä¸ºå®Œæ•´ç­–ç•¥çš„ä¸€éƒ¨åˆ†ï¼Œå¯ä»¥ä¸ºæ‰€æœ‰ç±»æ·»åŠ å‰ç¼€ï¼Œä¾‹å¦‚ FQDNï¼Œç„¶åŽåˆ›å»ºä¸€ä¸ªåŒ…å«æ‰€æœ‰ COM_WHATEVER_ClassName çš„æ ‡é¢˜ï¼ˆå¯ä»¥è‡ªåŠ¨ç”Ÿæˆæ‰€è¿°æ ‡é¢˜ï¼‰ã€‚

ç¼ºç‚¹ï¼š
å¿…é¡»åœ¨é™¤äº†ç¼–è¯‘å™¨ä¹‹å¤–çš„å­—ç¬¦ä¸²ä¸­è¾“å…¥éœ€è¦ç±»åçš„ä»»ä½•ä¸œè¥¿æ—¶è¾“å…¥çœŸæ­£çš„ç±»åï¼ˆä¾‹å¦‚ä¸Šé¢çš„ COM_WHATEVER_ClassNameï¼‰ã€‚

æ³¨æ„ï¼š
@compatibility_alias æ˜¯ç¼–è¯‘å™¨æŒ‡ä»¤ï¼Œè€Œä¸æ˜¯è¿è¡Œæ—¶å‡½æ•°ï¼Œå› æ­¤ NSClassFromString(ClassName) å°†å¤±è´¥ï¼ˆè¿”å›žnilï¼‰ 
å¿…é¡»ä½¿ç”¨NSClassFromString(COM_WHATERVER_ClassName)ã€‚å¯ä»¥é€šè¿‡æž„å»ºé˜¶æ®µä½¿ç”¨ ibtool æ¥ä¿®æ”¹ Interface Builder nib / xibä¸­çš„ç±»åï¼Œä»¥ä¾¿ä¸å¿…åœ¨ Interface Builder ä¸­ç¼–å†™å®Œæ•´çš„ COM_WHATEVER _...

è­¦å‘Šï¼š
å› ä¸ºè¿™æ˜¯ä¸€ä¸ªç¼–è¯‘å™¨æŒ‡ä»¤ï¼ˆå¹¶ä¸”æ˜¯ä¸€ä¸ªæ¨¡ç³Šçš„æŒ‡ä»¤ï¼‰ï¼Œå®ƒå¯èƒ½æ— æ³•è·¨ç¼–è¯‘å™¨ç§»æ¤ã€‚
```

#### æ–¹æ¡ˆäºŒï¼š

**Xcode æ–°å»ºé™æ€åº“å·¥ç¨‹ ==> æ‹–å…¥ç¬¬ä¸‰æ–¹åº“æºç   ==> ç¼–è¯‘äº§å‡ºé™æ€åº“  ==> åˆ†æž  ==> äº§å‡ºå®å®šä¹‰æ–‡ä»¶**

åˆ›å»ºä¸€ä¸ªå¤´æ–‡ä»¶ä½¿ç”¨å®å®šä¹‰æ¥å­˜åŽŸç¬¦å·å’Œé‡å‘½åç¬¦å·çš„å¯¹åº”å…³ç³»ã€‚è¿™é‡Œè¾¹æ‰¾åˆ°æ‰€æœ‰å†²çªç¬¦å·ç¼–å†™å®å®šä¹‰æ˜¯åŠ¨æ‰‹çš„éƒ¨åˆ†ã€‚æœ‰äººå†™è„šæœ¬ï¼Œæœ‰äººé æ‰‹åŠ¨ï¼Œçœ‹ä½ è‡ªå·±å–½

å¯¹äºŽåˆ†æž .oæ–‡ä»¶ä¸­çš„ç¬¦å·ï¼ŒæŽ¨èå·¥å…·ï¼š

- objdump

- readelf

> é¦–å…ˆï¼Œmacç³»ç»Ÿä¸‹çš„æ–‡ä»¶æ ¼å¼æ˜¯mach-oï¼Œå¹¶ä¸æ”¯æŒobjdumpå’Œreadelfï¼›
>  é€€è€Œæ±‚å…¶æ¬¡ï¼Œä½¿ç”¨`brew update && brew install binutils`ï¼Œç„¶åŽç”¨`greadelf`å’Œ`gobjdump`ï¼›
>
> æ³¨æ„ï¼Œä½¿ç”¨ä½¿ç”¨`brew update && brew install binutils`ä¼šæœ‰å¦‚ä¸‹æç¤ºï¼š
>
> 
>
> ```dart
> binutils is keg-only, which means it was not symlinked into /usr/local,
> because because Apple provides the same tools and binutils is poorly supported on macOS.
> 
> If you need to have binutils first in your PATH run:
>   echo 'export PATH="/usr/local/opt/binutils/bin:$PATH"' >> ~/.bash_profile
> 
> For compilers to find binutils you may need to set:
>   export LDFLAGS="-L/usr/local/opt/binutils/lib"
>   export CPPFLAGS="-I/usr/local/opt/binutils/include"
> ```
>
> æ„æ€å°±æ˜¯ `binutils` å¹¶æ²¡æœ‰ç¬¦å·é“¾æŽ¥ï¼Œå¹¶ä¸” macOS å¯¹ä»–çš„æ”¯æŒå¹¶ä¸å¥½ã€‚
>
> åœ¨ä½¿ç”¨ä¹‹å‰ï¼Œé¦–å…ˆéœ€è¦é…ç½®çš„è·¯å¾„ï¼Œèƒ½æ­£ç¡®é“¾æŽ¥ï¼Œæ ¹æ®æç¤ºæ“ä½œå°±å¯ä»¥äº†ã€‚
>
> é¦–å…ˆ
>
> ```bash
> echo 'export PATH="/usr/local/opt/binutils/bin:$PATH"' >> ~/.zshrc
> ```
>
> ç„¶åŽæ‰§è¡Œ `source` å‘½ä»¤è®©ä¿®æ”¹ç”Ÿæ•ˆã€‚
>
> ```bash
> source ~/.zshrc
> ```
>
> å¯ä»¥æ‰“å¼€ .zshrc æ–‡ä»¶æŸ¥çœ‹ï¼Œåœ¨æ–‡ä»¶æœ«å°¾æœ‰å¯ä»¥çœ‹åˆ°æ–°å¢ž
>  `export PATH="/usr/local/opt/binutils/bin:$PATH"`
>
> åŽé¢ä¾æ¬¡æ‰§è¡Œä¸‹é¢çš„å‘½ä»¤å°±å¯ä»¥äº†ã€‚
>
> ```bash
> export LDFLAGS="-L/usr/local/opt/binutils/lib"
> export CPPFLAGS="-I/usr/local/opt/binutils/include"
> ```
>
> ä¸‹é¢å°±å¯ä»¥ä½¿ç”¨ `gobjdump` å’Œ `greadelf` å‘½ä»¤äº†ã€‚
>  æˆ–è€… `objdump` å’Œ `readelf` ä¹Ÿæ˜¯å¯è¡Œçš„ ðŸ˜Ž
>
> 

- otool
- [nm](https://linuxtools-rst.readthedocs.io/zh_CN/latest/tool/nm.html)



