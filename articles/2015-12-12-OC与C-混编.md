---
title: OC与C++混编
date: 2015-12-12 20:11:31
tags:
- C++
- OC
- 混编
categories:
- C++
---

## 背景

项目中，我们项目中导入了新大陆、动联、赢联**蓝牙POS** `SDK`。他们提供的手机连接蓝牙的Demo中有一些`OC`调用 `C++` 的代码。我们根据他们提供的Demo，修改工程中的代码，也就出现了 `C++`与`Objective-C`混编的情况。

<!--more-->

## 实际项目中遇到的问题与解决

导入基本的依赖库`libstdC++` 这里就不多说了，直接说问题

### 遇到的问题

实际操作中还是出现令人费解的编译问题，比如最经典：

> Unknow type name ‘class’; did you mean ‘Class’ ?

究其原因就是我们没有遵守这两条规则：

- `.m`文件不能含有`C++`代码
- `.m`文件所`import`或`include`的`.h`文件中不能直接或间接包含`C++`代码

### 解决方法

在保证你的`C++`代码是正确前提下，如果发现相关编译错误可以通过如下几个方法修复：

1. 将`.h`文件中的`C++`代码转移到其他地方
2. 指定文件的编译类型
3. 将相关的`.m`文件后缀改成`.mm`，XCode就会自动判断该使用何种编译器来编译。

你有可能会忽视一个问题：

当你在`AppDelegate.h`中`include`或`import`一个`C++`的头文件时，当然你一定不会忘记修改`AppDelegate.m`为`AppDelegate.mm`，如果只做了这点儿还不够，我们还忽略了隐藏在`Supporting Files`组内的一个文件的存在`main.m`

在以前的XCode模板中main.m默认是这样的

```objective-c
#import ;

int main(int argc, char *argv[]) {
    NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
    int retVal = UIApplicationMain(argc, argv, nil, nil);
    [pool release];
    return retVal;
}
```

而新的模板是这样的：

```objective-c
#import ;
#import "AppDelegate.h"

int main(int argc, char *argv[]) {
    @autoreleasepool {
        return UIApplicationMain(argc, argv, nil, NSStringFromClass([AppDelegate class]));
    }
}
```

问题就是：`main.m`新增了`#import “AppDelegate.h"`，这就导致了`main.m`作为一个`Objective-C`源文件却引入了`C++`代码，而Xocde会使用`Objective-C`的编译器进行编译，从而产生编译错误，因此我们还需要将`main.m`的后缀改成`.mm`。



## 参考文献

- [c 与 c++ 混编详解 extern ”C“](https://blog.csdn.net/wushao126/article/details/40379907)
- [C++/OC 混编](https://blog.csdn.net/fengsh998/article/details/8010696)
- [Objective-C/C++混编编译器设置](https://blog.csdn.net/wangyuchun_799/article/details/7729222)